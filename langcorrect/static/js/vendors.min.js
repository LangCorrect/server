!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e(
        ((t =
          'undefined' != typeof globalThis ? globalThis : t || self).Popper =
          {}),
      );
})(this, function (t) {
  'use strict';
  function e(t) {
    if (null == t) return window;
    if ('[object Window]' !== t.toString()) {
      var e = t.ownerDocument;
      return (e && e.defaultView) || window;
    }
    return t;
  }
  function i(t) {
    return t instanceof e(t).Element || t instanceof Element;
  }
  function n(t) {
    return t instanceof e(t).HTMLElement || t instanceof HTMLElement;
  }
  function s(t) {
    return (
      'undefined' != typeof ShadowRoot &&
      (t instanceof e(t).ShadowRoot || t instanceof ShadowRoot)
    );
  }
  var o = Math.max,
    r = Math.min,
    a = Math.round;
  function l() {
    var t = navigator.userAgentData;
    return null != t && t.brands && Array.isArray(t.brands)
      ? t.brands
          .map(function (t) {
            return t.brand + '/' + t.version;
          })
          .join(' ')
      : navigator.userAgent;
  }
  function c() {
    return !/^((?!chrome|android).)*safari/i.test(l());
  }
  function h(t, s, o) {
    void 0 === s && (s = !1), void 0 === o && (o = !1);
    var r = t.getBoundingClientRect(),
      l = 1,
      h = 1;
    s &&
      n(t) &&
      ((l = (t.offsetWidth > 0 && a(r.width) / t.offsetWidth) || 1),
      (h = (t.offsetHeight > 0 && a(r.height) / t.offsetHeight) || 1));
    var u = (i(t) ? e(t) : window).visualViewport,
      d = !c() && o,
      f = (r.left + (d && u ? u.offsetLeft : 0)) / l,
      p = (r.top + (d && u ? u.offsetTop : 0)) / h,
      g = r.width / l,
      m = r.height / h;
    return {
      width: g,
      height: m,
      top: p,
      right: f + g,
      bottom: p + m,
      left: f,
      x: f,
      y: p,
    };
  }
  function u(t) {
    var i = e(t);
    return { scrollLeft: i.pageXOffset, scrollTop: i.pageYOffset };
  }
  function d(t) {
    return t ? (t.nodeName || '').toLowerCase() : null;
  }
  function f(t) {
    return ((i(t) ? t.ownerDocument : t.document) || window.document)
      .documentElement;
  }
  function p(t) {
    return h(f(t)).left + u(t).scrollLeft;
  }
  function g(t) {
    return e(t).getComputedStyle(t);
  }
  function m(t) {
    var e = g(t),
      i = e.overflow,
      n = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n);
  }
  function _(t, i, s) {
    void 0 === s && (s = !1);
    var o,
      r,
      l = n(i),
      c =
        n(i) &&
        (function (t) {
          var e = t.getBoundingClientRect(),
            i = a(e.width) / t.offsetWidth || 1,
            n = a(e.height) / t.offsetHeight || 1;
          return 1 !== i || 1 !== n;
        })(i),
      g = f(i),
      _ = h(t, c, s),
      b = { scrollLeft: 0, scrollTop: 0 },
      v = { x: 0, y: 0 };
    return (
      (l || (!l && !s)) &&
        (('body' !== d(i) || m(g)) &&
          (b =
            (o = i) !== e(o) && n(o)
              ? { scrollLeft: (r = o).scrollLeft, scrollTop: r.scrollTop }
              : u(o)),
        n(i)
          ? (((v = h(i, !0)).x += i.clientLeft), (v.y += i.clientTop))
          : g && (v.x = p(g))),
      {
        x: _.left + b.scrollLeft - v.x,
        y: _.top + b.scrollTop - v.y,
        width: _.width,
        height: _.height,
      }
    );
  }
  function b(t) {
    var e = h(t),
      i = t.offsetWidth,
      n = t.offsetHeight;
    return (
      Math.abs(e.width - i) <= 1 && (i = e.width),
      Math.abs(e.height - n) <= 1 && (n = e.height),
      { x: t.offsetLeft, y: t.offsetTop, width: i, height: n }
    );
  }
  function v(t) {
    return 'html' === d(t)
      ? t
      : t.assignedSlot || t.parentNode || (s(t) ? t.host : null) || f(t);
  }
  function y(t) {
    return ['html', 'body', '#document'].indexOf(d(t)) >= 0
      ? t.ownerDocument.body
      : n(t) && m(t)
      ? t
      : y(v(t));
  }
  function w(t, i) {
    var n;
    void 0 === i && (i = []);
    var s = y(t),
      o = s === (null == (n = t.ownerDocument) ? void 0 : n.body),
      r = e(s),
      a = o ? [r].concat(r.visualViewport || [], m(s) ? s : []) : s,
      l = i.concat(a);
    return o ? l : l.concat(w(v(a)));
  }
  function A(t) {
    return ['table', 'td', 'th'].indexOf(d(t)) >= 0;
  }
  function E(t) {
    return n(t) && 'fixed' !== g(t).position ? t.offsetParent : null;
  }
  function T(t) {
    for (var i = e(t), o = E(t); o && A(o) && 'static' === g(o).position; )
      o = E(o);
    return o &&
      ('html' === d(o) || ('body' === d(o) && 'static' === g(o).position))
      ? i
      : o ||
          (function (t) {
            var e = /firefox/i.test(l());
            if (/Trident/i.test(l()) && n(t) && 'fixed' === g(t).position)
              return null;
            var i = v(t);
            for (
              s(i) && (i = i.host);
              n(i) && ['html', 'body'].indexOf(d(i)) < 0;

            ) {
              var o = g(i);
              if (
                'none' !== o.transform ||
                'none' !== o.perspective ||
                'paint' === o.contain ||
                -1 !== ['transform', 'perspective'].indexOf(o.willChange) ||
                (e && 'filter' === o.willChange) ||
                (e && o.filter && 'none' !== o.filter)
              )
                return i;
              i = i.parentNode;
            }
            return null;
          })(t) ||
          i;
  }
  var C = 'top',
    O = 'bottom',
    x = 'right',
    k = 'left',
    L = 'auto',
    S = [C, O, x, k],
    D = 'start',
    $ = 'end',
    I = 'clippingParents',
    N = 'viewport',
    P = 'popper',
    j = 'reference',
    M = S.reduce(function (t, e) {
      return t.concat([e + '-' + D, e + '-' + $]);
    }, []),
    F = [].concat(S, [L]).reduce(function (t, e) {
      return t.concat([e, e + '-' + D, e + '-' + $]);
    }, []),
    H = [
      'beforeRead',
      'read',
      'afterRead',
      'beforeMain',
      'main',
      'afterMain',
      'beforeWrite',
      'write',
      'afterWrite',
    ];
  function B(t) {
    var e = new Map(),
      i = new Set(),
      n = [];
    function s(t) {
      i.add(t.name),
        []
          .concat(t.requires || [], t.requiresIfExists || [])
          .forEach(function (t) {
            if (!i.has(t)) {
              var n = e.get(t);
              n && s(n);
            }
          }),
        n.push(t);
    }
    return (
      t.forEach(function (t) {
        e.set(t.name, t);
      }),
      t.forEach(function (t) {
        i.has(t.name) || s(t);
      }),
      n
    );
  }
  function W(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && s(i)) {
      var n = e;
      do {
        if (n && t.isSameNode(n)) return !0;
        n = n.parentNode || n.host;
      } while (n);
    }
    return !1;
  }
  function z(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height,
    });
  }
  function q(t, n, s) {
    return n === N
      ? z(
          (function (t, i) {
            var n = e(t),
              s = f(t),
              o = n.visualViewport,
              r = s.clientWidth,
              a = s.clientHeight,
              l = 0,
              h = 0;
            if (o) {
              (r = o.width), (a = o.height);
              var u = c();
              (u || (!u && 'fixed' === i)) &&
                ((l = o.offsetLeft), (h = o.offsetTop));
            }
            return { width: r, height: a, x: l + p(t), y: h };
          })(t, s),
        )
      : i(n)
      ? (function (t, e) {
          var i = h(t, !1, 'fixed' === e);
          return (
            (i.top = i.top + t.clientTop),
            (i.left = i.left + t.clientLeft),
            (i.bottom = i.top + t.clientHeight),
            (i.right = i.left + t.clientWidth),
            (i.width = t.clientWidth),
            (i.height = t.clientHeight),
            (i.x = i.left),
            (i.y = i.top),
            i
          );
        })(n, s)
      : z(
          (function (t) {
            var e,
              i = f(t),
              n = u(t),
              s = null == (e = t.ownerDocument) ? void 0 : e.body,
              r = o(
                i.scrollWidth,
                i.clientWidth,
                s ? s.scrollWidth : 0,
                s ? s.clientWidth : 0,
              ),
              a = o(
                i.scrollHeight,
                i.clientHeight,
                s ? s.scrollHeight : 0,
                s ? s.clientHeight : 0,
              ),
              l = -n.scrollLeft + p(t),
              c = -n.scrollTop;
            return (
              'rtl' === g(s || i).direction &&
                (l += o(i.clientWidth, s ? s.clientWidth : 0) - r),
              { width: r, height: a, x: l, y: c }
            );
          })(f(t)),
        );
  }
  function R(t, e, s, a) {
    var l =
        'clippingParents' === e
          ? (function (t) {
              var e = w(v(t)),
                s =
                  ['absolute', 'fixed'].indexOf(g(t).position) >= 0 && n(t)
                    ? T(t)
                    : t;
              return i(s)
                ? e.filter(function (t) {
                    return i(t) && W(t, s) && 'body' !== d(t);
                  })
                : [];
            })(t)
          : [].concat(e),
      c = [].concat(l, [s]),
      h = c[0],
      u = c.reduce(
        function (e, i) {
          var n = q(t, i, a);
          return (
            (e.top = o(n.top, e.top)),
            (e.right = r(n.right, e.right)),
            (e.bottom = r(n.bottom, e.bottom)),
            (e.left = o(n.left, e.left)),
            e
          );
        },
        q(t, h, a),
      );
    return (
      (u.width = u.right - u.left),
      (u.height = u.bottom - u.top),
      (u.x = u.left),
      (u.y = u.top),
      u
    );
  }
  function V(t) {
    return t.split('-')[0];
  }
  function K(t) {
    return t.split('-')[1];
  }
  function Q(t) {
    return ['top', 'bottom'].indexOf(t) >= 0 ? 'x' : 'y';
  }
  function X(t) {
    var e,
      i = t.reference,
      n = t.element,
      s = t.placement,
      o = s ? V(s) : null,
      r = s ? K(s) : null,
      a = i.x + i.width / 2 - n.width / 2,
      l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
      case C:
        e = { x: a, y: i.y - n.height };
        break;
      case O:
        e = { x: a, y: i.y + i.height };
        break;
      case x:
        e = { x: i.x + i.width, y: l };
        break;
      case k:
        e = { x: i.x - n.width, y: l };
        break;
      default:
        e = { x: i.x, y: i.y };
    }
    var c = o ? Q(o) : null;
    if (null != c) {
      var h = 'y' === c ? 'height' : 'width';
      switch (r) {
        case D:
          e[c] = e[c] - (i[h] / 2 - n[h] / 2);
          break;
        case $:
          e[c] = e[c] + (i[h] / 2 - n[h] / 2);
      }
    }
    return e;
  }
  function Y(t) {
    return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t);
  }
  function U(t, e) {
    return e.reduce(function (e, i) {
      return (e[i] = t), e;
    }, {});
  }
  function G(t, e) {
    void 0 === e && (e = {});
    var n = e,
      s = n.placement,
      o = void 0 === s ? t.placement : s,
      r = n.strategy,
      a = void 0 === r ? t.strategy : r,
      l = n.boundary,
      c = void 0 === l ? I : l,
      u = n.rootBoundary,
      d = void 0 === u ? N : u,
      p = n.elementContext,
      g = void 0 === p ? P : p,
      m = n.altBoundary,
      _ = void 0 !== m && m,
      b = n.padding,
      v = void 0 === b ? 0 : b,
      y = Y('number' != typeof v ? v : U(v, S)),
      w = g === P ? j : P,
      A = t.rects.popper,
      E = t.elements[_ ? w : g],
      T = R(i(E) ? E : E.contextElement || f(t.elements.popper), c, d, a),
      k = h(t.elements.reference),
      L = X({ reference: k, element: A, strategy: 'absolute', placement: o }),
      D = z(Object.assign({}, A, L)),
      $ = g === P ? D : k,
      M = {
        top: T.top - $.top + y.top,
        bottom: $.bottom - T.bottom + y.bottom,
        left: T.left - $.left + y.left,
        right: $.right - T.right + y.right,
      },
      F = t.modifiersData.offset;
    if (g === P && F) {
      var H = F[o];
      Object.keys(M).forEach(function (t) {
        var e = [x, O].indexOf(t) >= 0 ? 1 : -1,
          i = [C, O].indexOf(t) >= 0 ? 'y' : 'x';
        M[t] += H[i] * e;
      });
    }
    return M;
  }
  var J = { placement: 'bottom', modifiers: [], strategy: 'absolute' };
  function Z() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
      e[i] = arguments[i];
    return !e.some(function (t) {
      return !(t && 'function' == typeof t.getBoundingClientRect);
    });
  }
  function tt(t) {
    void 0 === t && (t = {});
    var e = t,
      n = e.defaultModifiers,
      s = void 0 === n ? [] : n,
      o = e.defaultOptions,
      r = void 0 === o ? J : o;
    return function (t, e, n) {
      void 0 === n && (n = r);
      var o,
        a,
        l = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, J, r),
          modifiersData: {},
          elements: { reference: t, popper: e },
          attributes: {},
          styles: {},
        },
        c = [],
        h = !1,
        u = {
          state: l,
          setOptions: function (n) {
            var o = 'function' == typeof n ? n(l.options) : n;
            d(),
              (l.options = Object.assign({}, r, l.options, o)),
              (l.scrollParents = {
                reference: i(t)
                  ? w(t)
                  : t.contextElement
                  ? w(t.contextElement)
                  : [],
                popper: w(e),
              });
            var a,
              h,
              f = (function (t) {
                var e = B(t);
                return H.reduce(function (t, i) {
                  return t.concat(
                    e.filter(function (t) {
                      return t.phase === i;
                    }),
                  );
                }, []);
              })(
                ((a = [].concat(s, l.options.modifiers)),
                (h = a.reduce(function (t, e) {
                  var i = t[e.name];
                  return (
                    (t[e.name] = i
                      ? Object.assign({}, i, e, {
                          options: Object.assign({}, i.options, e.options),
                          data: Object.assign({}, i.data, e.data),
                        })
                      : e),
                    t
                  );
                }, {})),
                Object.keys(h).map(function (t) {
                  return h[t];
                })),
              );
            return (
              (l.orderedModifiers = f.filter(function (t) {
                return t.enabled;
              })),
              l.orderedModifiers.forEach(function (t) {
                var e = t.name,
                  i = t.options,
                  n = void 0 === i ? {} : i,
                  s = t.effect;
                if ('function' == typeof s) {
                  var o = s({ state: l, name: e, instance: u, options: n }),
                    r = function () {};
                  c.push(o || r);
                }
              }),
              u.update()
            );
          },
          forceUpdate: function () {
            if (!h) {
              var t = l.elements,
                e = t.reference,
                i = t.popper;
              if (Z(e, i)) {
                (l.rects = {
                  reference: _(e, T(i), 'fixed' === l.options.strategy),
                  popper: b(i),
                }),
                  (l.reset = !1),
                  (l.placement = l.options.placement),
                  l.orderedModifiers.forEach(function (t) {
                    return (l.modifiersData[t.name] = Object.assign(
                      {},
                      t.data,
                    ));
                  });
                for (var n = 0; n < l.orderedModifiers.length; n++)
                  if (!0 !== l.reset) {
                    var s = l.orderedModifiers[n],
                      o = s.fn,
                      r = s.options,
                      a = void 0 === r ? {} : r,
                      c = s.name;
                    'function' == typeof o &&
                      (l =
                        o({ state: l, options: a, name: c, instance: u }) || l);
                  } else (l.reset = !1), (n = -1);
              }
            }
          },
          update:
            ((o = function () {
              return new Promise(function (t) {
                u.forceUpdate(), t(l);
              });
            }),
            function () {
              return (
                a ||
                  (a = new Promise(function (t) {
                    Promise.resolve().then(function () {
                      (a = void 0), t(o());
                    });
                  })),
                a
              );
            }),
          destroy: function () {
            d(), (h = !0);
          },
        };
      if (!Z(t, e)) return u;
      function d() {
        c.forEach(function (t) {
          return t();
        }),
          (c = []);
      }
      return (
        u.setOptions(n).then(function (t) {
          !h && n.onFirstUpdate && n.onFirstUpdate(t);
        }),
        u
      );
    };
  }
  var et = { passive: !0 };
  var it = {
    name: 'eventListeners',
    enabled: !0,
    phase: 'write',
    fn: function () {},
    effect: function (t) {
      var i = t.state,
        n = t.instance,
        s = t.options,
        o = s.scroll,
        r = void 0 === o || o,
        a = s.resize,
        l = void 0 === a || a,
        c = e(i.elements.popper),
        h = [].concat(i.scrollParents.reference, i.scrollParents.popper);
      return (
        r &&
          h.forEach(function (t) {
            t.addEventListener('scroll', n.update, et);
          }),
        l && c.addEventListener('resize', n.update, et),
        function () {
          r &&
            h.forEach(function (t) {
              t.removeEventListener('scroll', n.update, et);
            }),
            l && c.removeEventListener('resize', n.update, et);
        }
      );
    },
    data: {},
  };
  var nt = {
      name: 'popperOffsets',
      enabled: !0,
      phase: 'read',
      fn: function (t) {
        var e = t.state,
          i = t.name;
        e.modifiersData[i] = X({
          reference: e.rects.reference,
          element: e.rects.popper,
          strategy: 'absolute',
          placement: e.placement,
        });
      },
      data: {},
    },
    st = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' };
  function ot(t) {
    var i,
      n = t.popper,
      s = t.popperRect,
      o = t.placement,
      r = t.variation,
      l = t.offsets,
      c = t.position,
      h = t.gpuAcceleration,
      u = t.adaptive,
      d = t.roundOffsets,
      p = t.isFixed,
      m = l.x,
      _ = void 0 === m ? 0 : m,
      b = l.y,
      v = void 0 === b ? 0 : b,
      y = 'function' == typeof d ? d({ x: _, y: v }) : { x: _, y: v };
    (_ = y.x), (v = y.y);
    var w = l.hasOwnProperty('x'),
      A = l.hasOwnProperty('y'),
      E = k,
      L = C,
      S = window;
    if (u) {
      var D = T(n),
        I = 'clientHeight',
        N = 'clientWidth';
      if (
        (D === e(n) &&
          'static' !== g((D = f(n))).position &&
          'absolute' === c &&
          ((I = 'scrollHeight'), (N = 'scrollWidth')),
        o === C || ((o === k || o === x) && r === $))
      )
        (L = O),
          (v -=
            (p && D === S && S.visualViewport
              ? S.visualViewport.height
              : D[I]) - s.height),
          (v *= h ? 1 : -1);
      if (o === k || ((o === C || o === O) && r === $))
        (E = x),
          (_ -=
            (p && D === S && S.visualViewport ? S.visualViewport.width : D[N]) -
            s.width),
          (_ *= h ? 1 : -1);
    }
    var P,
      j = Object.assign({ position: c }, u && st),
      M =
        !0 === d
          ? (function (t, e) {
              var i = t.x,
                n = t.y,
                s = e.devicePixelRatio || 1;
              return { x: a(i * s) / s || 0, y: a(n * s) / s || 0 };
            })({ x: _, y: v }, e(n))
          : { x: _, y: v };
    return (
      (_ = M.x),
      (v = M.y),
      h
        ? Object.assign(
            {},
            j,
            (((P = {})[L] = A ? '0' : ''),
            (P[E] = w ? '0' : ''),
            (P.transform =
              (S.devicePixelRatio || 1) <= 1
                ? 'translate(' + _ + 'px, ' + v + 'px)'
                : 'translate3d(' + _ + 'px, ' + v + 'px, 0)'),
            P),
          )
        : Object.assign(
            {},
            j,
            (((i = {})[L] = A ? v + 'px' : ''),
            (i[E] = w ? _ + 'px' : ''),
            (i.transform = ''),
            i),
          )
    );
  }
  var rt = {
    name: 'computeStyles',
    enabled: !0,
    phase: 'beforeWrite',
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = i.gpuAcceleration,
        s = void 0 === n || n,
        o = i.adaptive,
        r = void 0 === o || o,
        a = i.roundOffsets,
        l = void 0 === a || a,
        c = {
          placement: V(e.placement),
          variation: K(e.placement),
          popper: e.elements.popper,
          popperRect: e.rects.popper,
          gpuAcceleration: s,
          isFixed: 'fixed' === e.options.strategy,
        };
      null != e.modifiersData.popperOffsets &&
        (e.styles.popper = Object.assign(
          {},
          e.styles.popper,
          ot(
            Object.assign({}, c, {
              offsets: e.modifiersData.popperOffsets,
              position: e.options.strategy,
              adaptive: r,
              roundOffsets: l,
            }),
          ),
        )),
        null != e.modifiersData.arrow &&
          (e.styles.arrow = Object.assign(
            {},
            e.styles.arrow,
            ot(
              Object.assign({}, c, {
                offsets: e.modifiersData.arrow,
                position: 'absolute',
                adaptive: !1,
                roundOffsets: l,
              }),
            ),
          )),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, {
          'data-popper-placement': e.placement,
        }));
    },
    data: {},
  };
  var at = {
    name: 'applyStyles',
    enabled: !0,
    phase: 'write',
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function (t) {
        var i = e.styles[t] || {},
          s = e.attributes[t] || {},
          o = e.elements[t];
        n(o) &&
          d(o) &&
          (Object.assign(o.style, i),
          Object.keys(s).forEach(function (t) {
            var e = s[t];
            !1 === e
              ? o.removeAttribute(t)
              : o.setAttribute(t, !0 === e ? '' : e);
          }));
      });
    },
    effect: function (t) {
      var e = t.state,
        i = {
          popper: {
            position: e.options.strategy,
            left: '0',
            top: '0',
            margin: '0',
          },
          arrow: { position: 'absolute' },
          reference: {},
        };
      return (
        Object.assign(e.elements.popper.style, i.popper),
        (e.styles = i),
        e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow),
        function () {
          Object.keys(e.elements).forEach(function (t) {
            var s = e.elements[t],
              o = e.attributes[t] || {},
              r = Object.keys(
                e.styles.hasOwnProperty(t) ? e.styles[t] : i[t],
              ).reduce(function (t, e) {
                return (t[e] = ''), t;
              }, {});
            n(s) &&
              d(s) &&
              (Object.assign(s.style, r),
              Object.keys(o).forEach(function (t) {
                s.removeAttribute(t);
              }));
          });
        }
      );
    },
    requires: ['computeStyles'],
  };
  var lt = {
      name: 'offset',
      enabled: !0,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.offset,
          o = void 0 === s ? [0, 0] : s,
          r = F.reduce(function (t, i) {
            return (
              (t[i] = (function (t, e, i) {
                var n = V(t),
                  s = [k, C].indexOf(n) >= 0 ? -1 : 1,
                  o =
                    'function' == typeof i
                      ? i(Object.assign({}, e, { placement: t }))
                      : i,
                  r = o[0],
                  a = o[1];
                return (
                  (r = r || 0),
                  (a = (a || 0) * s),
                  [k, x].indexOf(n) >= 0 ? { x: a, y: r } : { x: r, y: a }
                );
              })(i, e.rects, o)),
              t
            );
          }, {}),
          a = r[e.placement],
          l = a.x,
          c = a.y;
        null != e.modifiersData.popperOffsets &&
          ((e.modifiersData.popperOffsets.x += l),
          (e.modifiersData.popperOffsets.y += c)),
          (e.modifiersData[n] = r);
      },
    },
    ct = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  function ht(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return ct[t];
    });
  }
  var ut = { start: 'end', end: 'start' };
  function dt(t) {
    return t.replace(/start|end/g, function (t) {
      return ut[t];
    });
  }
  function ft(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = i.boundary,
      o = i.rootBoundary,
      r = i.padding,
      a = i.flipVariations,
      l = i.allowedAutoPlacements,
      c = void 0 === l ? F : l,
      h = K(n),
      u = h
        ? a
          ? M
          : M.filter(function (t) {
              return K(t) === h;
            })
        : S,
      d = u.filter(function (t) {
        return c.indexOf(t) >= 0;
      });
    0 === d.length && (d = u);
    var f = d.reduce(function (e, i) {
      return (
        (e[i] = G(t, {
          placement: i,
          boundary: s,
          rootBoundary: o,
          padding: r,
        })[V(i)]),
        e
      );
    }, {});
    return Object.keys(f).sort(function (t, e) {
      return f[t] - f[e];
    });
  }
  var pt = {
    name: 'flip',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = t.name;
      if (!e.modifiersData[n]._skip) {
        for (
          var s = i.mainAxis,
            o = void 0 === s || s,
            r = i.altAxis,
            a = void 0 === r || r,
            l = i.fallbackPlacements,
            c = i.padding,
            h = i.boundary,
            u = i.rootBoundary,
            d = i.altBoundary,
            f = i.flipVariations,
            p = void 0 === f || f,
            g = i.allowedAutoPlacements,
            m = e.options.placement,
            _ = V(m),
            b =
              l ||
              (_ === m || !p
                ? [ht(m)]
                : (function (t) {
                    if (V(t) === L) return [];
                    var e = ht(t);
                    return [dt(t), e, dt(e)];
                  })(m)),
            v = [m].concat(b).reduce(function (t, i) {
              return t.concat(
                V(i) === L
                  ? ft(e, {
                      placement: i,
                      boundary: h,
                      rootBoundary: u,
                      padding: c,
                      flipVariations: p,
                      allowedAutoPlacements: g,
                    })
                  : i,
              );
            }, []),
            y = e.rects.reference,
            w = e.rects.popper,
            A = new Map(),
            E = !0,
            T = v[0],
            S = 0;
          S < v.length;
          S++
        ) {
          var $ = v[S],
            I = V($),
            N = K($) === D,
            P = [C, O].indexOf(I) >= 0,
            j = P ? 'width' : 'height',
            M = G(e, {
              placement: $,
              boundary: h,
              rootBoundary: u,
              altBoundary: d,
              padding: c,
            }),
            F = P ? (N ? x : k) : N ? O : C;
          y[j] > w[j] && (F = ht(F));
          var H = ht(F),
            B = [];
          if (
            (o && B.push(M[I] <= 0),
            a && B.push(M[F] <= 0, M[H] <= 0),
            B.every(function (t) {
              return t;
            }))
          ) {
            (T = $), (E = !1);
            break;
          }
          A.set($, B);
        }
        if (E)
          for (
            var W = function (t) {
                var e = v.find(function (e) {
                  var i = A.get(e);
                  if (i)
                    return i.slice(0, t).every(function (t) {
                      return t;
                    });
                });
                if (e) return (T = e), 'break';
              },
              z = p ? 3 : 1;
            z > 0;
            z--
          ) {
            if ('break' === W(z)) break;
          }
        e.placement !== T &&
          ((e.modifiersData[n]._skip = !0), (e.placement = T), (e.reset = !0));
      }
    },
    requiresIfExists: ['offset'],
    data: { _skip: !1 },
  };
  function gt(t, e, i) {
    return o(t, r(e, i));
  }
  var mt = {
    name: 'preventOverflow',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = t.name,
        s = i.mainAxis,
        a = void 0 === s || s,
        l = i.altAxis,
        c = void 0 !== l && l,
        h = i.boundary,
        u = i.rootBoundary,
        d = i.altBoundary,
        f = i.padding,
        p = i.tether,
        g = void 0 === p || p,
        m = i.tetherOffset,
        _ = void 0 === m ? 0 : m,
        v = G(e, { boundary: h, rootBoundary: u, padding: f, altBoundary: d }),
        y = V(e.placement),
        w = K(e.placement),
        A = !w,
        E = Q(y),
        L = 'x' === E ? 'y' : 'x',
        S = e.modifiersData.popperOffsets,
        $ = e.rects.reference,
        I = e.rects.popper,
        N =
          'function' == typeof _
            ? _(Object.assign({}, e.rects, { placement: e.placement }))
            : _,
        P =
          'number' == typeof N
            ? { mainAxis: N, altAxis: N }
            : Object.assign({ mainAxis: 0, altAxis: 0 }, N),
        j = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
        M = { x: 0, y: 0 };
      if (S) {
        if (a) {
          var F,
            H = 'y' === E ? C : k,
            B = 'y' === E ? O : x,
            W = 'y' === E ? 'height' : 'width',
            z = S[E],
            q = z + v[H],
            R = z - v[B],
            X = g ? -I[W] / 2 : 0,
            Y = w === D ? $[W] : I[W],
            U = w === D ? -I[W] : -$[W],
            J = e.elements.arrow,
            Z = g && J ? b(J) : { width: 0, height: 0 },
            tt = e.modifiersData['arrow#persistent']
              ? e.modifiersData['arrow#persistent'].padding
              : { top: 0, right: 0, bottom: 0, left: 0 },
            et = tt[H],
            it = tt[B],
            nt = gt(0, $[W], Z[W]),
            st = A
              ? $[W] / 2 - X - nt - et - P.mainAxis
              : Y - nt - et - P.mainAxis,
            ot = A
              ? -$[W] / 2 + X + nt + it + P.mainAxis
              : U + nt + it + P.mainAxis,
            rt = e.elements.arrow && T(e.elements.arrow),
            at = rt ? ('y' === E ? rt.clientTop || 0 : rt.clientLeft || 0) : 0,
            lt = null != (F = null == j ? void 0 : j[E]) ? F : 0,
            ct = z + ot - lt,
            ht = gt(g ? r(q, z + st - lt - at) : q, z, g ? o(R, ct) : R);
          (S[E] = ht), (M[E] = ht - z);
        }
        if (c) {
          var ut,
            dt = 'x' === E ? C : k,
            ft = 'x' === E ? O : x,
            pt = S[L],
            mt = 'y' === L ? 'height' : 'width',
            _t = pt + v[dt],
            bt = pt - v[ft],
            vt = -1 !== [C, k].indexOf(y),
            yt = null != (ut = null == j ? void 0 : j[L]) ? ut : 0,
            wt = vt ? _t : pt - $[mt] - I[mt] - yt + P.altAxis,
            At = vt ? pt + $[mt] + I[mt] - yt - P.altAxis : bt,
            Et =
              g && vt
                ? (function (t, e, i) {
                    var n = gt(t, e, i);
                    return n > i ? i : n;
                  })(wt, pt, At)
                : gt(g ? wt : _t, pt, g ? At : bt);
          (S[L] = Et), (M[L] = Et - pt);
        }
        e.modifiersData[n] = M;
      }
    },
    requiresIfExists: ['offset'],
  };
  var _t = {
    name: 'arrow',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      var e,
        i = t.state,
        n = t.name,
        s = t.options,
        o = i.elements.arrow,
        r = i.modifiersData.popperOffsets,
        a = V(i.placement),
        l = Q(a),
        c = [k, x].indexOf(a) >= 0 ? 'height' : 'width';
      if (o && r) {
        var h = (function (t, e) {
            return Y(
              'number' !=
                typeof (t =
                  'function' == typeof t
                    ? t(Object.assign({}, e.rects, { placement: e.placement }))
                    : t)
                ? t
                : U(t, S),
            );
          })(s.padding, i),
          u = b(o),
          d = 'y' === l ? C : k,
          f = 'y' === l ? O : x,
          p =
            i.rects.reference[c] +
            i.rects.reference[l] -
            r[l] -
            i.rects.popper[c],
          g = r[l] - i.rects.reference[l],
          m = T(o),
          _ = m ? ('y' === l ? m.clientHeight || 0 : m.clientWidth || 0) : 0,
          v = p / 2 - g / 2,
          y = h[d],
          w = _ - u[c] - h[f],
          A = _ / 2 - u[c] / 2 + v,
          E = gt(y, A, w),
          L = l;
        i.modifiersData[n] = (((e = {})[L] = E), (e.centerOffset = E - A), e);
      }
    },
    effect: function (t) {
      var e = t.state,
        i = t.options.element,
        n = void 0 === i ? '[data-popper-arrow]' : i;
      null != n &&
        ('string' != typeof n || (n = e.elements.popper.querySelector(n))) &&
        W(e.elements.popper, n) &&
        (e.elements.arrow = n);
    },
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow'],
  };
  function bt(t, e, i) {
    return (
      void 0 === i && (i = { x: 0, y: 0 }),
      {
        top: t.top - e.height - i.y,
        right: t.right - e.width + i.x,
        bottom: t.bottom - e.height + i.y,
        left: t.left - e.width - i.x,
      }
    );
  }
  function vt(t) {
    return [C, x, O, k].some(function (e) {
      return t[e] >= 0;
    });
  }
  var yt = {
      name: 'hide',
      enabled: !0,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: function (t) {
        var e = t.state,
          i = t.name,
          n = e.rects.reference,
          s = e.rects.popper,
          o = e.modifiersData.preventOverflow,
          r = G(e, { elementContext: 'reference' }),
          a = G(e, { altBoundary: !0 }),
          l = bt(r, n),
          c = bt(a, s, o),
          h = vt(l),
          u = vt(c);
        (e.modifiersData[i] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: h,
          hasPopperEscaped: u,
        }),
          (e.attributes.popper = Object.assign({}, e.attributes.popper, {
            'data-popper-reference-hidden': h,
            'data-popper-escaped': u,
          }));
      },
    },
    wt = tt({ defaultModifiers: [it, nt, rt, at] }),
    At = [it, nt, rt, at, lt, pt, mt, _t, yt],
    Et = tt({ defaultModifiers: At });
  (t.applyStyles = at),
    (t.arrow = _t),
    (t.computeStyles = rt),
    (t.createPopper = Et),
    (t.createPopperLite = wt),
    (t.defaultModifiers = At),
    (t.detectOverflow = G),
    (t.eventListeners = it),
    (t.flip = pt),
    (t.hide = yt),
    (t.offset = lt),
    (t.popperGenerator = tt),
    (t.popperOffsets = nt),
    (t.preventOverflow = mt),
    Object.defineProperty(t, '__esModule', { value: !0 });
}),
  /*!
   * Bootstrap v5.3.2 (https://getbootstrap.com/)
   * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   */
  (function (t, e) {
    'object' == typeof exports && 'undefined' != typeof module
      ? (module.exports = e(require('@popperjs/core')))
      : 'function' == typeof define && define.amd
      ? define(['@popperjs/core'], e)
      : ((t =
          'undefined' != typeof globalThis ? globalThis : t || self).bootstrap =
          e(t.Popper));
  })(this, function (t) {
    'use strict';
    function e(t) {
      const e = Object.create(null, {
        [Symbol.toStringTag]: { value: 'Module' },
      });
      if (t)
        for (const i in t)
          if ('default' !== i) {
            const n = Object.getOwnPropertyDescriptor(t, i);
            Object.defineProperty(
              e,
              i,
              n.get ? n : { enumerable: !0, get: () => t[i] },
            );
          }
      return (e.default = t), Object.freeze(e);
    }
    const i = e(t),
      n = new Map(),
      s = {
        set(t, e, i) {
          n.has(t) || n.set(t, new Map());
          const s = n.get(t);
          s.has(e) || 0 === s.size
            ? s.set(e, i)
            : console.error(
                `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
                  Array.from(s.keys())[0]
                }.`,
              );
        },
        get: (t, e) => (n.has(t) && n.get(t).get(e)) || null,
        remove(t, e) {
          if (!n.has(t)) return;
          const i = n.get(t);
          i.delete(e), 0 === i.size && n.delete(t);
        },
      },
      o = 'transitionend',
      r = (t) => (
        t &&
          window.CSS &&
          window.CSS.escape &&
          (t = t.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)),
        t
      ),
      a = (t) => {
        t.dispatchEvent(new Event(o));
      },
      l = (t) =>
        !(!t || 'object' != typeof t) &&
        (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
      c = (t) =>
        l(t)
          ? t.jquery
            ? t[0]
            : t
          : 'string' == typeof t && t.length > 0
          ? document.querySelector(r(t))
          : null,
      h = (t) => {
        if (!l(t) || 0 === t.getClientRects().length) return !1;
        const e =
            'visible' === getComputedStyle(t).getPropertyValue('visibility'),
          i = t.closest('details:not([open])');
        if (!i) return e;
        if (i !== t) {
          const e = t.closest('summary');
          if (e && e.parentNode !== i) return !1;
          if (null === e) return !1;
        }
        return e;
      },
      u = (t) =>
        !t ||
        t.nodeType !== Node.ELEMENT_NODE ||
        !!t.classList.contains('disabled') ||
        (void 0 !== t.disabled
          ? t.disabled
          : t.hasAttribute('disabled') &&
            'false' !== t.getAttribute('disabled')),
      d = (t) => {
        if (!document.documentElement.attachShadow) return null;
        if ('function' == typeof t.getRootNode) {
          const e = t.getRootNode();
          return e instanceof ShadowRoot ? e : null;
        }
        return t instanceof ShadowRoot
          ? t
          : t.parentNode
          ? d(t.parentNode)
          : null;
      },
      f = () => {},
      p = (t) => {
        t.offsetHeight;
      },
      g = () =>
        window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')
          ? window.jQuery
          : null,
      m = [],
      _ = () => 'rtl' === document.documentElement.dir,
      b = (t) => {
        var e;
        (e = () => {
          const e = g();
          if (e) {
            const i = t.NAME,
              n = e.fn[i];
            (e.fn[i] = t.jQueryInterface),
              (e.fn[i].Constructor = t),
              (e.fn[i].noConflict = () => ((e.fn[i] = n), t.jQueryInterface));
          }
        }),
          'loading' === document.readyState
            ? (m.length ||
                document.addEventListener('DOMContentLoaded', () => {
                  for (const t of m) t();
                }),
              m.push(e))
            : e();
      },
      v = (t, e = [], i = t) => ('function' == typeof t ? t(...e) : i),
      y = (t, e, i = !0) => {
        if (!i) return void v(t);
        const n =
          ((t) => {
            if (!t) return 0;
            let { transitionDuration: e, transitionDelay: i } =
              window.getComputedStyle(t);
            const n = Number.parseFloat(e),
              s = Number.parseFloat(i);
            return n || s
              ? ((e = e.split(',')[0]),
                (i = i.split(',')[0]),
                1e3 * (Number.parseFloat(e) + Number.parseFloat(i)))
              : 0;
          })(e) + 5;
        let s = !1;
        const r = ({ target: i }) => {
          i === e && ((s = !0), e.removeEventListener(o, r), v(t));
        };
        e.addEventListener(o, r),
          setTimeout(() => {
            s || a(e);
          }, n);
      },
      w = (t, e, i, n) => {
        const s = t.length;
        let o = t.indexOf(e);
        return -1 === o
          ? !i && n
            ? t[s - 1]
            : t[0]
          : ((o += i ? 1 : -1),
            n && (o = (o + s) % s),
            t[Math.max(0, Math.min(o, s - 1))]);
      },
      A = /[^.]*(?=\..*)\.|.*/,
      E = /\..*/,
      T = /::\d+$/,
      C = {};
    let O = 1;
    const x = { mouseenter: 'mouseover', mouseleave: 'mouseout' },
      k = new Set([
        'click',
        'dblclick',
        'mouseup',
        'mousedown',
        'contextmenu',
        'mousewheel',
        'DOMMouseScroll',
        'mouseover',
        'mouseout',
        'mousemove',
        'selectstart',
        'selectend',
        'keydown',
        'keypress',
        'keyup',
        'orientationchange',
        'touchstart',
        'touchmove',
        'touchend',
        'touchcancel',
        'pointerdown',
        'pointermove',
        'pointerup',
        'pointerleave',
        'pointercancel',
        'gesturestart',
        'gesturechange',
        'gestureend',
        'focus',
        'blur',
        'change',
        'reset',
        'select',
        'submit',
        'focusin',
        'focusout',
        'load',
        'unload',
        'beforeunload',
        'resize',
        'move',
        'DOMContentLoaded',
        'readystatechange',
        'error',
        'abort',
        'scroll',
      ]);
    function L(t, e) {
      return (e && `${e}::${O++}`) || t.uidEvent || O++;
    }
    function S(t) {
      const e = L(t);
      return (t.uidEvent = e), (C[e] = C[e] || {}), C[e];
    }
    function D(t, e, i = null) {
      return Object.values(t).find(
        (t) => t.callable === e && t.delegationSelector === i,
      );
    }
    function $(t, e, i) {
      const n = 'string' == typeof e,
        s = n ? i : e || i;
      let o = j(t);
      return k.has(o) || (o = t), [n, s, o];
    }
    function I(t, e, i, n, s) {
      if ('string' != typeof e || !t) return;
      let [o, r, a] = $(e, i, n);
      if (e in x) {
        const t = (t) =>
          function (e) {
            if (
              !e.relatedTarget ||
              (e.relatedTarget !== e.delegateTarget &&
                !e.delegateTarget.contains(e.relatedTarget))
            )
              return t.call(this, e);
          };
        r = t(r);
      }
      const l = S(t),
        c = l[a] || (l[a] = {}),
        h = D(c, r, o ? i : null);
      if (h) return void (h.oneOff = h.oneOff && s);
      const u = L(r, e.replace(A, '')),
        d = o
          ? (function (t, e, i) {
              return function n(s) {
                const o = t.querySelectorAll(e);
                for (let { target: r } = s; r && r !== this; r = r.parentNode)
                  for (const a of o)
                    if (a === r)
                      return (
                        F(s, { delegateTarget: r }),
                        n.oneOff && M.off(t, s.type, e, i),
                        i.apply(r, [s])
                      );
              };
            })(t, i, r)
          : (function (t, e) {
              return function i(n) {
                return (
                  F(n, { delegateTarget: t }),
                  i.oneOff && M.off(t, n.type, e),
                  e.apply(t, [n])
                );
              };
            })(t, r);
      (d.delegationSelector = o ? i : null),
        (d.callable = r),
        (d.oneOff = s),
        (d.uidEvent = u),
        (c[u] = d),
        t.addEventListener(a, d, o);
    }
    function N(t, e, i, n, s) {
      const o = D(e[i], n, s);
      o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);
    }
    function P(t, e, i, n) {
      const s = e[i] || {};
      for (const [o, r] of Object.entries(s))
        o.includes(n) && N(t, e, i, r.callable, r.delegationSelector);
    }
    function j(t) {
      return (t = t.replace(E, '')), x[t] || t;
    }
    const M = {
      on(t, e, i, n) {
        I(t, e, i, n, !1);
      },
      one(t, e, i, n) {
        I(t, e, i, n, !0);
      },
      off(t, e, i, n) {
        if ('string' != typeof e || !t) return;
        const [s, o, r] = $(e, i, n),
          a = r !== e,
          l = S(t),
          c = l[r] || {},
          h = e.startsWith('.');
        if (void 0 === o) {
          if (h) for (const i of Object.keys(l)) P(t, l, i, e.slice(1));
          for (const [i, n] of Object.entries(c)) {
            const s = i.replace(T, '');
            (a && !e.includes(s)) ||
              N(t, l, r, n.callable, n.delegationSelector);
          }
        } else {
          if (!Object.keys(c).length) return;
          N(t, l, r, o, s ? i : null);
        }
      },
      trigger(t, e, i) {
        if ('string' != typeof e || !t) return null;
        const n = g();
        let s = null,
          o = !0,
          r = !0,
          a = !1;
        e !== j(e) &&
          n &&
          ((s = n.Event(e, i)),
          n(t).trigger(s),
          (o = !s.isPropagationStopped()),
          (r = !s.isImmediatePropagationStopped()),
          (a = s.isDefaultPrevented()));
        const l = F(new Event(e, { bubbles: o, cancelable: !0 }), i);
        return (
          a && l.preventDefault(),
          r && t.dispatchEvent(l),
          l.defaultPrevented && s && s.preventDefault(),
          l
        );
      },
    };
    function F(t, e = {}) {
      for (const [i, n] of Object.entries(e))
        try {
          t[i] = n;
        } catch (e) {
          Object.defineProperty(t, i, { configurable: !0, get: () => n });
        }
      return t;
    }
    function H(t) {
      if ('true' === t) return !0;
      if ('false' === t) return !1;
      if (t === Number(t).toString()) return Number(t);
      if ('' === t || 'null' === t) return null;
      if ('string' != typeof t) return t;
      try {
        return JSON.parse(decodeURIComponent(t));
      } catch (e) {
        return t;
      }
    }
    function B(t) {
      return t.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
    }
    const W = {
      setDataAttribute(t, e, i) {
        t.setAttribute(`data-bs-${B(e)}`, i);
      },
      removeDataAttribute(t, e) {
        t.removeAttribute(`data-bs-${B(e)}`);
      },
      getDataAttributes(t) {
        if (!t) return {};
        const e = {},
          i = Object.keys(t.dataset).filter(
            (t) => t.startsWith('bs') && !t.startsWith('bsConfig'),
          );
        for (const n of i) {
          let i = n.replace(/^bs/, '');
          (i = i.charAt(0).toLowerCase() + i.slice(1, i.length)),
            (e[i] = H(t.dataset[n]));
        }
        return e;
      },
      getDataAttribute: (t, e) => H(t.getAttribute(`data-bs-${B(e)}`)),
    };
    class z {
      static get Default() {
        return {};
      }
      static get DefaultType() {
        return {};
      }
      static get NAME() {
        throw new Error(
          'You have to implement the static method "NAME", for each component!',
        );
      }
      _getConfig(t) {
        return (
          (t = this._mergeConfigObj(t)),
          (t = this._configAfterMerge(t)),
          this._typeCheckConfig(t),
          t
        );
      }
      _configAfterMerge(t) {
        return t;
      }
      _mergeConfigObj(t, e) {
        const i = l(e) ? W.getDataAttribute(e, 'config') : {};
        return {
          ...this.constructor.Default,
          ...('object' == typeof i ? i : {}),
          ...(l(e) ? W.getDataAttributes(e) : {}),
          ...('object' == typeof t ? t : {}),
        };
      }
      _typeCheckConfig(t, e = this.constructor.DefaultType) {
        for (const [n, s] of Object.entries(e)) {
          const e = t[n],
            o = l(e)
              ? 'element'
              : null == (i = e)
              ? `${i}`
              : Object.prototype.toString
                  .call(i)
                  .match(/\s([a-z]+)/i)[1]
                  .toLowerCase();
          if (!new RegExp(s).test(o))
            throw new TypeError(
              `${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${o}" but expected type "${s}".`,
            );
        }
        var i;
      }
    }
    class q extends z {
      constructor(t, e) {
        super(),
          (t = c(t)) &&
            ((this._element = t),
            (this._config = this._getConfig(e)),
            s.set(this._element, this.constructor.DATA_KEY, this));
      }
      dispose() {
        s.remove(this._element, this.constructor.DATA_KEY),
          M.off(this._element, this.constructor.EVENT_KEY);
        for (const t of Object.getOwnPropertyNames(this)) this[t] = null;
      }
      _queueCallback(t, e, i = !0) {
        y(t, e, i);
      }
      _getConfig(t) {
        return (
          (t = this._mergeConfigObj(t, this._element)),
          (t = this._configAfterMerge(t)),
          this._typeCheckConfig(t),
          t
        );
      }
      static getInstance(t) {
        return s.get(c(t), this.DATA_KEY);
      }
      static getOrCreateInstance(t, e = {}) {
        return (
          this.getInstance(t) || new this(t, 'object' == typeof e ? e : null)
        );
      }
      static get VERSION() {
        return '5.3.2';
      }
      static get DATA_KEY() {
        return `bs.${this.NAME}`;
      }
      static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
      }
      static eventName(t) {
        return `${t}${this.EVENT_KEY}`;
      }
    }
    const R = (t) => {
        let e = t.getAttribute('data-bs-target');
        if (!e || '#' === e) {
          let i = t.getAttribute('href');
          if (!i || (!i.includes('#') && !i.startsWith('.'))) return null;
          i.includes('#') && !i.startsWith('#') && (i = `#${i.split('#')[1]}`),
            (e = i && '#' !== i ? r(i.trim()) : null);
        }
        return e;
      },
      V = {
        find: (t, e = document.documentElement) =>
          [].concat(...Element.prototype.querySelectorAll.call(e, t)),
        findOne: (t, e = document.documentElement) =>
          Element.prototype.querySelector.call(e, t),
        children: (t, e) =>
          [].concat(...t.children).filter((t) => t.matches(e)),
        parents(t, e) {
          const i = [];
          let n = t.parentNode.closest(e);
          for (; n; ) i.push(n), (n = n.parentNode.closest(e));
          return i;
        },
        prev(t, e) {
          let i = t.previousElementSibling;
          for (; i; ) {
            if (i.matches(e)) return [i];
            i = i.previousElementSibling;
          }
          return [];
        },
        next(t, e) {
          let i = t.nextElementSibling;
          for (; i; ) {
            if (i.matches(e)) return [i];
            i = i.nextElementSibling;
          }
          return [];
        },
        focusableChildren(t) {
          const e = [
            'a',
            'button',
            'input',
            'textarea',
            'select',
            'details',
            '[tabindex]',
            '[contenteditable="true"]',
          ]
            .map((t) => `${t}:not([tabindex^="-"])`)
            .join(',');
          return this.find(e, t).filter((t) => !u(t) && h(t));
        },
        getSelectorFromElement(t) {
          const e = R(t);
          return e && V.findOne(e) ? e : null;
        },
        getElementFromSelector(t) {
          const e = R(t);
          return e ? V.findOne(e) : null;
        },
        getMultipleElementsFromSelector(t) {
          const e = R(t);
          return e ? V.find(e) : [];
        },
      },
      K = (t, e = 'hide') => {
        const i = `click.dismiss${t.EVENT_KEY}`,
          n = t.NAME;
        M.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) {
          if (
            (['A', 'AREA'].includes(this.tagName) && i.preventDefault(),
            u(this))
          )
            return;
          const s = V.getElementFromSelector(this) || this.closest(`.${n}`);
          t.getOrCreateInstance(s)[e]();
        });
      },
      Q = '.bs.alert',
      X = `close${Q}`,
      Y = `closed${Q}`;
    class U extends q {
      static get NAME() {
        return 'alert';
      }
      close() {
        if (M.trigger(this._element, X).defaultPrevented) return;
        this._element.classList.remove('show');
        const t = this._element.classList.contains('fade');
        this._queueCallback(() => this._destroyElement(), this._element, t);
      }
      _destroyElement() {
        this._element.remove(), M.trigger(this._element, Y), this.dispose();
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = U.getOrCreateInstance(this);
          if ('string' == typeof t) {
            if (void 0 === e[t] || t.startsWith('_') || 'constructor' === t)
              throw new TypeError(`No method named "${t}"`);
            e[t](this);
          }
        });
      }
    }
    K(U, 'close'), b(U);
    const G = '[data-bs-toggle="button"]';
    class J extends q {
      static get NAME() {
        return 'button';
      }
      toggle() {
        this._element.setAttribute(
          'aria-pressed',
          this._element.classList.toggle('active'),
        );
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = J.getOrCreateInstance(this);
          'toggle' === t && e[t]();
        });
      }
    }
    M.on(document, 'click.bs.button.data-api', G, (t) => {
      t.preventDefault();
      const e = t.target.closest(G);
      J.getOrCreateInstance(e).toggle();
    }),
      b(J);
    const Z = '.bs.swipe',
      tt = `touchstart${Z}`,
      et = `touchmove${Z}`,
      it = `touchend${Z}`,
      nt = `pointerdown${Z}`,
      st = `pointerup${Z}`,
      ot = { endCallback: null, leftCallback: null, rightCallback: null },
      rt = {
        endCallback: '(function|null)',
        leftCallback: '(function|null)',
        rightCallback: '(function|null)',
      };
    class at extends z {
      constructor(t, e) {
        super(),
          (this._element = t),
          t &&
            at.isSupported() &&
            ((this._config = this._getConfig(e)),
            (this._deltaX = 0),
            (this._supportPointerEvents = Boolean(window.PointerEvent)),
            this._initEvents());
      }
      static get Default() {
        return ot;
      }
      static get DefaultType() {
        return rt;
      }
      static get NAME() {
        return 'swipe';
      }
      dispose() {
        M.off(this._element, Z);
      }
      _start(t) {
        this._supportPointerEvents
          ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
          : (this._deltaX = t.touches[0].clientX);
      }
      _end(t) {
        this._eventIsPointerPenTouch(t) &&
          (this._deltaX = t.clientX - this._deltaX),
          this._handleSwipe(),
          v(this._config.endCallback);
      }
      _move(t) {
        this._deltaX =
          t.touches && t.touches.length > 1
            ? 0
            : t.touches[0].clientX - this._deltaX;
      }
      _handleSwipe() {
        const t = Math.abs(this._deltaX);
        if (t <= 40) return;
        const e = t / this._deltaX;
        (this._deltaX = 0),
          e &&
            v(e > 0 ? this._config.rightCallback : this._config.leftCallback);
      }
      _initEvents() {
        this._supportPointerEvents
          ? (M.on(this._element, nt, (t) => this._start(t)),
            M.on(this._element, st, (t) => this._end(t)),
            this._element.classList.add('pointer-event'))
          : (M.on(this._element, tt, (t) => this._start(t)),
            M.on(this._element, et, (t) => this._move(t)),
            M.on(this._element, it, (t) => this._end(t)));
      }
      _eventIsPointerPenTouch(t) {
        return (
          this._supportPointerEvents &&
          ('pen' === t.pointerType || 'touch' === t.pointerType)
        );
      }
      static isSupported() {
        return (
          'ontouchstart' in document.documentElement ||
          navigator.maxTouchPoints > 0
        );
      }
    }
    const lt = '.bs.carousel',
      ct = '.data-api',
      ht = 'next',
      ut = 'prev',
      dt = 'left',
      ft = 'right',
      pt = `slide${lt}`,
      gt = `slid${lt}`,
      mt = `keydown${lt}`,
      _t = `mouseenter${lt}`,
      bt = `mouseleave${lt}`,
      vt = `dragstart${lt}`,
      yt = `load${lt}${ct}`,
      wt = `click${lt}${ct}`,
      At = 'carousel',
      Et = 'active',
      Tt = '.active',
      Ct = '.carousel-item',
      Ot = Tt + Ct,
      xt = { ArrowLeft: ft, ArrowRight: dt },
      kt = {
        interval: 5e3,
        keyboard: !0,
        pause: 'hover',
        ride: !1,
        touch: !0,
        wrap: !0,
      },
      Lt = {
        interval: '(number|boolean)',
        keyboard: 'boolean',
        pause: '(string|boolean)',
        ride: '(boolean|string)',
        touch: 'boolean',
        wrap: 'boolean',
      };
    class St extends q {
      constructor(t, e) {
        super(t, e),
          (this._interval = null),
          (this._activeElement = null),
          (this._isSliding = !1),
          (this.touchTimeout = null),
          (this._swipeHelper = null),
          (this._indicatorsElement = V.findOne(
            '.carousel-indicators',
            this._element,
          )),
          this._addEventListeners(),
          this._config.ride === At && this.cycle();
      }
      static get Default() {
        return kt;
      }
      static get DefaultType() {
        return Lt;
      }
      static get NAME() {
        return 'carousel';
      }
      next() {
        this._slide(ht);
      }
      nextWhenVisible() {
        !document.hidden && h(this._element) && this.next();
      }
      prev() {
        this._slide(ut);
      }
      pause() {
        this._isSliding && a(this._element), this._clearInterval();
      }
      cycle() {
        this._clearInterval(),
          this._updateInterval(),
          (this._interval = setInterval(
            () => this.nextWhenVisible(),
            this._config.interval,
          ));
      }
      _maybeEnableCycle() {
        this._config.ride &&
          (this._isSliding
            ? M.one(this._element, gt, () => this.cycle())
            : this.cycle());
      }
      to(t) {
        const e = this._getItems();
        if (t > e.length - 1 || t < 0) return;
        if (this._isSliding)
          return void M.one(this._element, gt, () => this.to(t));
        const i = this._getItemIndex(this._getActive());
        if (i === t) return;
        const n = t > i ? ht : ut;
        this._slide(n, e[t]);
      }
      dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
      }
      _configAfterMerge(t) {
        return (t.defaultInterval = t.interval), t;
      }
      _addEventListeners() {
        this._config.keyboard &&
          M.on(this._element, mt, (t) => this._keydown(t)),
          'hover' === this._config.pause &&
            (M.on(this._element, _t, () => this.pause()),
            M.on(this._element, bt, () => this._maybeEnableCycle())),
          this._config.touch &&
            at.isSupported() &&
            this._addTouchEventListeners();
      }
      _addTouchEventListeners() {
        for (const t of V.find('.carousel-item img', this._element))
          M.on(t, vt, (t) => t.preventDefault());
        const t = {
          leftCallback: () => this._slide(this._directionToOrder(dt)),
          rightCallback: () => this._slide(this._directionToOrder(ft)),
          endCallback: () => {
            'hover' === this._config.pause &&
              (this.pause(),
              this.touchTimeout && clearTimeout(this.touchTimeout),
              (this.touchTimeout = setTimeout(
                () => this._maybeEnableCycle(),
                500 + this._config.interval,
              )));
          },
        };
        this._swipeHelper = new at(this._element, t);
      }
      _keydown(t) {
        if (/input|textarea/i.test(t.target.tagName)) return;
        const e = xt[t.key];
        e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
      }
      _getItemIndex(t) {
        return this._getItems().indexOf(t);
      }
      _setActiveIndicatorElement(t) {
        if (!this._indicatorsElement) return;
        const e = V.findOne(Tt, this._indicatorsElement);
        e.classList.remove(Et), e.removeAttribute('aria-current');
        const i = V.findOne(
          `[data-bs-slide-to="${t}"]`,
          this._indicatorsElement,
        );
        i && (i.classList.add(Et), i.setAttribute('aria-current', 'true'));
      }
      _updateInterval() {
        const t = this._activeElement || this._getActive();
        if (!t) return;
        const e = Number.parseInt(t.getAttribute('data-bs-interval'), 10);
        this._config.interval = e || this._config.defaultInterval;
      }
      _slide(t, e = null) {
        if (this._isSliding) return;
        const i = this._getActive(),
          n = t === ht,
          s = e || w(this._getItems(), i, n, this._config.wrap);
        if (s === i) return;
        const o = this._getItemIndex(s),
          r = (e) =>
            M.trigger(this._element, e, {
              relatedTarget: s,
              direction: this._orderToDirection(t),
              from: this._getItemIndex(i),
              to: o,
            });
        if (r(pt).defaultPrevented) return;
        if (!i || !s) return;
        const a = Boolean(this._interval);
        this.pause(),
          (this._isSliding = !0),
          this._setActiveIndicatorElement(o),
          (this._activeElement = s);
        const l = n ? 'carousel-item-start' : 'carousel-item-end',
          c = n ? 'carousel-item-next' : 'carousel-item-prev';
        s.classList.add(c), p(s), i.classList.add(l), s.classList.add(l);
        this._queueCallback(
          () => {
            s.classList.remove(l, c),
              s.classList.add(Et),
              i.classList.remove(Et, c, l),
              (this._isSliding = !1),
              r(gt);
          },
          i,
          this._isAnimated(),
        ),
          a && this.cycle();
      }
      _isAnimated() {
        return this._element.classList.contains('slide');
      }
      _getActive() {
        return V.findOne(Ot, this._element);
      }
      _getItems() {
        return V.find(Ct, this._element);
      }
      _clearInterval() {
        this._interval &&
          (clearInterval(this._interval), (this._interval = null));
      }
      _directionToOrder(t) {
        return _() ? (t === dt ? ut : ht) : t === dt ? ht : ut;
      }
      _orderToDirection(t) {
        return _() ? (t === ut ? dt : ft) : t === ut ? ft : dt;
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = St.getOrCreateInstance(this, t);
          if ('number' != typeof t) {
            if ('string' == typeof t) {
              if (void 0 === e[t] || t.startsWith('_') || 'constructor' === t)
                throw new TypeError(`No method named "${t}"`);
              e[t]();
            }
          } else e.to(t);
        });
      }
    }
    M.on(document, wt, '[data-bs-slide], [data-bs-slide-to]', function (t) {
      const e = V.getElementFromSelector(this);
      if (!e || !e.classList.contains(At)) return;
      t.preventDefault();
      const i = St.getOrCreateInstance(e),
        n = this.getAttribute('data-bs-slide-to');
      return n
        ? (i.to(n), void i._maybeEnableCycle())
        : 'next' === W.getDataAttribute(this, 'slide')
        ? (i.next(), void i._maybeEnableCycle())
        : (i.prev(), void i._maybeEnableCycle());
    }),
      M.on(window, yt, () => {
        const t = V.find('[data-bs-ride="carousel"]');
        for (const e of t) St.getOrCreateInstance(e);
      }),
      b(St);
    const Dt = '.bs.collapse',
      $t = `show${Dt}`,
      It = `shown${Dt}`,
      Nt = `hide${Dt}`,
      Pt = `hidden${Dt}`,
      jt = `click${Dt}.data-api`,
      Mt = 'show',
      Ft = 'collapse',
      Ht = 'collapsing',
      Bt = `:scope .${Ft} .${Ft}`,
      Wt = '[data-bs-toggle="collapse"]',
      zt = { parent: null, toggle: !0 },
      qt = { parent: '(null|element)', toggle: 'boolean' };
    class Rt extends q {
      constructor(t, e) {
        super(t, e), (this._isTransitioning = !1), (this._triggerArray = []);
        const i = V.find(Wt);
        for (const t of i) {
          const e = V.getSelectorFromElement(t),
            i = V.find(e).filter((t) => t === this._element);
          null !== e && i.length && this._triggerArray.push(t);
        }
        this._initializeChildren(),
          this._config.parent ||
            this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
          this._config.toggle && this.toggle();
      }
      static get Default() {
        return zt;
      }
      static get DefaultType() {
        return qt;
      }
      static get NAME() {
        return 'collapse';
      }
      toggle() {
        this._isShown() ? this.hide() : this.show();
      }
      show() {
        if (this._isTransitioning || this._isShown()) return;
        let t = [];
        if (
          (this._config.parent &&
            (t = this._getFirstLevelChildren(
              '.collapse.show, .collapse.collapsing',
            )
              .filter((t) => t !== this._element)
              .map((t) => Rt.getOrCreateInstance(t, { toggle: !1 }))),
          t.length && t[0]._isTransitioning)
        )
          return;
        if (M.trigger(this._element, $t).defaultPrevented) return;
        for (const e of t) e.hide();
        const e = this._getDimension();
        this._element.classList.remove(Ft),
          this._element.classList.add(Ht),
          (this._element.style[e] = 0),
          this._addAriaAndCollapsedClass(this._triggerArray, !0),
          (this._isTransitioning = !0);
        const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
        this._queueCallback(
          () => {
            (this._isTransitioning = !1),
              this._element.classList.remove(Ht),
              this._element.classList.add(Ft, Mt),
              (this._element.style[e] = ''),
              M.trigger(this._element, It);
          },
          this._element,
          !0,
        ),
          (this._element.style[e] = `${this._element[i]}px`);
      }
      hide() {
        if (this._isTransitioning || !this._isShown()) return;
        if (M.trigger(this._element, Nt).defaultPrevented) return;
        const t = this._getDimension();
        (this._element.style[t] = `${
          this._element.getBoundingClientRect()[t]
        }px`),
          p(this._element),
          this._element.classList.add(Ht),
          this._element.classList.remove(Ft, Mt);
        for (const t of this._triggerArray) {
          const e = V.getElementFromSelector(t);
          e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1);
        }
        this._isTransitioning = !0;
        (this._element.style[t] = ''),
          this._queueCallback(
            () => {
              (this._isTransitioning = !1),
                this._element.classList.remove(Ht),
                this._element.classList.add(Ft),
                M.trigger(this._element, Pt);
            },
            this._element,
            !0,
          );
      }
      _isShown(t = this._element) {
        return t.classList.contains(Mt);
      }
      _configAfterMerge(t) {
        return (t.toggle = Boolean(t.toggle)), (t.parent = c(t.parent)), t;
      }
      _getDimension() {
        return this._element.classList.contains('collapse-horizontal')
          ? 'width'
          : 'height';
      }
      _initializeChildren() {
        if (!this._config.parent) return;
        const t = this._getFirstLevelChildren(Wt);
        for (const e of t) {
          const t = V.getElementFromSelector(e);
          t && this._addAriaAndCollapsedClass([e], this._isShown(t));
        }
      }
      _getFirstLevelChildren(t) {
        const e = V.find(Bt, this._config.parent);
        return V.find(t, this._config.parent).filter((t) => !e.includes(t));
      }
      _addAriaAndCollapsedClass(t, e) {
        if (t.length)
          for (const i of t)
            i.classList.toggle('collapsed', !e),
              i.setAttribute('aria-expanded', e);
      }
      static jQueryInterface(t) {
        const e = {};
        return (
          'string' == typeof t && /show|hide/.test(t) && (e.toggle = !1),
          this.each(function () {
            const i = Rt.getOrCreateInstance(this, e);
            if ('string' == typeof t) {
              if (void 0 === i[t])
                throw new TypeError(`No method named "${t}"`);
              i[t]();
            }
          })
        );
      }
    }
    M.on(document, jt, Wt, function (t) {
      ('A' === t.target.tagName ||
        (t.delegateTarget && 'A' === t.delegateTarget.tagName)) &&
        t.preventDefault();
      for (const t of V.getMultipleElementsFromSelector(this))
        Rt.getOrCreateInstance(t, { toggle: !1 }).toggle();
    }),
      b(Rt);
    const Vt = 'dropdown',
      Kt = '.bs.dropdown',
      Qt = '.data-api',
      Xt = 'ArrowUp',
      Yt = 'ArrowDown',
      Ut = `hide${Kt}`,
      Gt = `hidden${Kt}`,
      Jt = `show${Kt}`,
      Zt = `shown${Kt}`,
      te = `click${Kt}${Qt}`,
      ee = `keydown${Kt}${Qt}`,
      ie = `keyup${Kt}${Qt}`,
      ne = 'show',
      se = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
      oe = `${se}.${ne}`,
      re = '.dropdown-menu',
      ae = _() ? 'top-end' : 'top-start',
      le = _() ? 'top-start' : 'top-end',
      ce = _() ? 'bottom-end' : 'bottom-start',
      he = _() ? 'bottom-start' : 'bottom-end',
      ue = _() ? 'left-start' : 'right-start',
      de = _() ? 'right-start' : 'left-start',
      fe = {
        autoClose: !0,
        boundary: 'clippingParents',
        display: 'dynamic',
        offset: [0, 2],
        popperConfig: null,
        reference: 'toggle',
      },
      pe = {
        autoClose: '(boolean|string)',
        boundary: '(string|element)',
        display: 'string',
        offset: '(array|string|function)',
        popperConfig: '(null|object|function)',
        reference: '(string|element|object)',
      };
    class ge extends q {
      constructor(t, e) {
        super(t, e),
          (this._popper = null),
          (this._parent = this._element.parentNode),
          (this._menu =
            V.next(this._element, re)[0] ||
            V.prev(this._element, re)[0] ||
            V.findOne(re, this._parent)),
          (this._inNavbar = this._detectNavbar());
      }
      static get Default() {
        return fe;
      }
      static get DefaultType() {
        return pe;
      }
      static get NAME() {
        return Vt;
      }
      toggle() {
        return this._isShown() ? this.hide() : this.show();
      }
      show() {
        if (u(this._element) || this._isShown()) return;
        const t = { relatedTarget: this._element };
        if (!M.trigger(this._element, Jt, t).defaultPrevented) {
          if (
            (this._createPopper(),
            'ontouchstart' in document.documentElement &&
              !this._parent.closest('.navbar-nav'))
          )
            for (const t of [].concat(...document.body.children))
              M.on(t, 'mouseover', f);
          this._element.focus(),
            this._element.setAttribute('aria-expanded', !0),
            this._menu.classList.add(ne),
            this._element.classList.add(ne),
            M.trigger(this._element, Zt, t);
        }
      }
      hide() {
        if (u(this._element) || !this._isShown()) return;
        const t = { relatedTarget: this._element };
        this._completeHide(t);
      }
      dispose() {
        this._popper && this._popper.destroy(), super.dispose();
      }
      update() {
        (this._inNavbar = this._detectNavbar()),
          this._popper && this._popper.update();
      }
      _completeHide(t) {
        if (!M.trigger(this._element, Ut, t).defaultPrevented) {
          if ('ontouchstart' in document.documentElement)
            for (const t of [].concat(...document.body.children))
              M.off(t, 'mouseover', f);
          this._popper && this._popper.destroy(),
            this._menu.classList.remove(ne),
            this._element.classList.remove(ne),
            this._element.setAttribute('aria-expanded', 'false'),
            W.removeDataAttribute(this._menu, 'popper'),
            M.trigger(this._element, Gt, t);
        }
      }
      _getConfig(t) {
        if (
          'object' == typeof (t = super._getConfig(t)).reference &&
          !l(t.reference) &&
          'function' != typeof t.reference.getBoundingClientRect
        )
          throw new TypeError(
            `${Vt.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`,
          );
        return t;
      }
      _createPopper() {
        if (void 0 === i)
          throw new TypeError(
            "Bootstrap's dropdowns require Popper (https://popper.js.org)",
          );
        let t = this._element;
        'parent' === this._config.reference
          ? (t = this._parent)
          : l(this._config.reference)
          ? (t = c(this._config.reference))
          : 'object' == typeof this._config.reference &&
            (t = this._config.reference);
        const e = this._getPopperConfig();
        this._popper = i.createPopper(t, this._menu, e);
      }
      _isShown() {
        return this._menu.classList.contains(ne);
      }
      _getPlacement() {
        const t = this._parent;
        if (t.classList.contains('dropend')) return ue;
        if (t.classList.contains('dropstart')) return de;
        if (t.classList.contains('dropup-center')) return 'top';
        if (t.classList.contains('dropdown-center')) return 'bottom';
        const e =
          'end' ===
          getComputedStyle(this._menu).getPropertyValue('--bs-position').trim();
        return t.classList.contains('dropup') ? (e ? le : ae) : e ? he : ce;
      }
      _detectNavbar() {
        return null !== this._element.closest('.navbar');
      }
      _getOffset() {
        const { offset: t } = this._config;
        return 'string' == typeof t
          ? t.split(',').map((t) => Number.parseInt(t, 10))
          : 'function' == typeof t
          ? (e) => t(e, this._element)
          : t;
      }
      _getPopperConfig() {
        const t = {
          placement: this._getPlacement(),
          modifiers: [
            {
              name: 'preventOverflow',
              options: { boundary: this._config.boundary },
            },
            { name: 'offset', options: { offset: this._getOffset() } },
          ],
        };
        return (
          (this._inNavbar || 'static' === this._config.display) &&
            (W.setDataAttribute(this._menu, 'popper', 'static'),
            (t.modifiers = [{ name: 'applyStyles', enabled: !1 }])),
          { ...t, ...v(this._config.popperConfig, [t]) }
        );
      }
      _selectMenuItem({ key: t, target: e }) {
        const i = V.find(
          '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)',
          this._menu,
        ).filter((t) => h(t));
        i.length && w(i, e, t === Yt, !i.includes(e)).focus();
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = ge.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        });
      }
      static clearMenus(t) {
        if (2 === t.button || ('keyup' === t.type && 'Tab' !== t.key)) return;
        const e = V.find(oe);
        for (const i of e) {
          const e = ge.getInstance(i);
          if (!e || !1 === e._config.autoClose) continue;
          const n = t.composedPath(),
            s = n.includes(e._menu);
          if (
            n.includes(e._element) ||
            ('inside' === e._config.autoClose && !s) ||
            ('outside' === e._config.autoClose && s)
          )
            continue;
          if (
            e._menu.contains(t.target) &&
            (('keyup' === t.type && 'Tab' === t.key) ||
              /input|select|option|textarea|form/i.test(t.target.tagName))
          )
            continue;
          const o = { relatedTarget: e._element };
          'click' === t.type && (o.clickEvent = t), e._completeHide(o);
        }
      }
      static dataApiKeydownHandler(t) {
        const e = /input|textarea/i.test(t.target.tagName),
          i = 'Escape' === t.key,
          n = [Xt, Yt].includes(t.key);
        if (!n && !i) return;
        if (e && !i) return;
        t.preventDefault();
        const s = this.matches(se)
            ? this
            : V.prev(this, se)[0] ||
              V.next(this, se)[0] ||
              V.findOne(se, t.delegateTarget.parentNode),
          o = ge.getOrCreateInstance(s);
        if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
        o._isShown() && (t.stopPropagation(), o.hide(), s.focus());
      }
    }
    M.on(document, ee, se, ge.dataApiKeydownHandler),
      M.on(document, ee, re, ge.dataApiKeydownHandler),
      M.on(document, te, ge.clearMenus),
      M.on(document, ie, ge.clearMenus),
      M.on(document, te, se, function (t) {
        t.preventDefault(), ge.getOrCreateInstance(this).toggle();
      }),
      b(ge);
    const me = 'backdrop',
      _e = 'show',
      be = `mousedown.bs.${me}`,
      ve = {
        className: 'modal-backdrop',
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: 'body',
      },
      ye = {
        className: 'string',
        clickCallback: '(function|null)',
        isAnimated: 'boolean',
        isVisible: 'boolean',
        rootElement: '(element|string)',
      };
    class we extends z {
      constructor(t) {
        super(),
          (this._config = this._getConfig(t)),
          (this._isAppended = !1),
          (this._element = null);
      }
      static get Default() {
        return ve;
      }
      static get DefaultType() {
        return ye;
      }
      static get NAME() {
        return me;
      }
      show(t) {
        if (!this._config.isVisible) return void v(t);
        this._append();
        const e = this._getElement();
        this._config.isAnimated && p(e),
          e.classList.add(_e),
          this._emulateAnimation(() => {
            v(t);
          });
      }
      hide(t) {
        this._config.isVisible
          ? (this._getElement().classList.remove(_e),
            this._emulateAnimation(() => {
              this.dispose(), v(t);
            }))
          : v(t);
      }
      dispose() {
        this._isAppended &&
          (M.off(this._element, be),
          this._element.remove(),
          (this._isAppended = !1));
      }
      _getElement() {
        if (!this._element) {
          const t = document.createElement('div');
          (t.className = this._config.className),
            this._config.isAnimated && t.classList.add('fade'),
            (this._element = t);
        }
        return this._element;
      }
      _configAfterMerge(t) {
        return (t.rootElement = c(t.rootElement)), t;
      }
      _append() {
        if (this._isAppended) return;
        const t = this._getElement();
        this._config.rootElement.append(t),
          M.on(t, be, () => {
            v(this._config.clickCallback);
          }),
          (this._isAppended = !0);
      }
      _emulateAnimation(t) {
        y(t, this._getElement(), this._config.isAnimated);
      }
    }
    const Ae = '.bs.focustrap',
      Ee = `focusin${Ae}`,
      Te = `keydown.tab${Ae}`,
      Ce = 'backward',
      Oe = { autofocus: !0, trapElement: null },
      xe = { autofocus: 'boolean', trapElement: 'element' };
    class ke extends z {
      constructor(t) {
        super(),
          (this._config = this._getConfig(t)),
          (this._isActive = !1),
          (this._lastTabNavDirection = null);
      }
      static get Default() {
        return Oe;
      }
      static get DefaultType() {
        return xe;
      }
      static get NAME() {
        return 'focustrap';
      }
      activate() {
        this._isActive ||
          (this._config.autofocus && this._config.trapElement.focus(),
          M.off(document, Ae),
          M.on(document, Ee, (t) => this._handleFocusin(t)),
          M.on(document, Te, (t) => this._handleKeydown(t)),
          (this._isActive = !0));
      }
      deactivate() {
        this._isActive && ((this._isActive = !1), M.off(document, Ae));
      }
      _handleFocusin(t) {
        const { trapElement: e } = this._config;
        if (t.target === document || t.target === e || e.contains(t.target))
          return;
        const i = V.focusableChildren(e);
        0 === i.length
          ? e.focus()
          : this._lastTabNavDirection === Ce
          ? i[i.length - 1].focus()
          : i[0].focus();
      }
      _handleKeydown(t) {
        'Tab' === t.key &&
          (this._lastTabNavDirection = t.shiftKey ? Ce : 'forward');
      }
    }
    const Le = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
      Se = '.sticky-top',
      De = 'padding-right',
      $e = 'margin-right';
    class Ie {
      constructor() {
        this._element = document.body;
      }
      getWidth() {
        const t = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - t);
      }
      hide() {
        const t = this.getWidth();
        this._disableOverFlow(),
          this._setElementAttributes(this._element, De, (e) => e + t),
          this._setElementAttributes(Le, De, (e) => e + t),
          this._setElementAttributes(Se, $e, (e) => e - t);
      }
      reset() {
        this._resetElementAttributes(this._element, 'overflow'),
          this._resetElementAttributes(this._element, De),
          this._resetElementAttributes(Le, De),
          this._resetElementAttributes(Se, $e);
      }
      isOverflowing() {
        return this.getWidth() > 0;
      }
      _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow'),
          (this._element.style.overflow = 'hidden');
      }
      _setElementAttributes(t, e, i) {
        const n = this.getWidth();
        this._applyManipulationCallback(t, (t) => {
          if (t !== this._element && window.innerWidth > t.clientWidth + n)
            return;
          this._saveInitialAttribute(t, e);
          const s = window.getComputedStyle(t).getPropertyValue(e);
          t.style.setProperty(e, `${i(Number.parseFloat(s))}px`);
        });
      }
      _saveInitialAttribute(t, e) {
        const i = t.style.getPropertyValue(e);
        i && W.setDataAttribute(t, e, i);
      }
      _resetElementAttributes(t, e) {
        this._applyManipulationCallback(t, (t) => {
          const i = W.getDataAttribute(t, e);
          null !== i
            ? (W.removeDataAttribute(t, e), t.style.setProperty(e, i))
            : t.style.removeProperty(e);
        });
      }
      _applyManipulationCallback(t, e) {
        if (l(t)) e(t);
        else for (const i of V.find(t, this._element)) e(i);
      }
    }
    const Ne = '.bs.modal',
      Pe = `hide${Ne}`,
      je = `hidePrevented${Ne}`,
      Me = `hidden${Ne}`,
      Fe = `show${Ne}`,
      He = `shown${Ne}`,
      Be = `resize${Ne}`,
      We = `click.dismiss${Ne}`,
      ze = `mousedown.dismiss${Ne}`,
      qe = `keydown.dismiss${Ne}`,
      Re = `click${Ne}.data-api`,
      Ve = 'modal-open',
      Ke = 'show',
      Qe = 'modal-static',
      Xe = { backdrop: !0, focus: !0, keyboard: !0 },
      Ye = {
        backdrop: '(boolean|string)',
        focus: 'boolean',
        keyboard: 'boolean',
      };
    class Ue extends q {
      constructor(t, e) {
        super(t, e),
          (this._dialog = V.findOne('.modal-dialog', this._element)),
          (this._backdrop = this._initializeBackDrop()),
          (this._focustrap = this._initializeFocusTrap()),
          (this._isShown = !1),
          (this._isTransitioning = !1),
          (this._scrollBar = new Ie()),
          this._addEventListeners();
      }
      static get Default() {
        return Xe;
      }
      static get DefaultType() {
        return Ye;
      }
      static get NAME() {
        return 'modal';
      }
      toggle(t) {
        return this._isShown ? this.hide() : this.show(t);
      }
      show(t) {
        if (this._isShown || this._isTransitioning) return;
        M.trigger(this._element, Fe, { relatedTarget: t }).defaultPrevented ||
          ((this._isShown = !0),
          (this._isTransitioning = !0),
          this._scrollBar.hide(),
          document.body.classList.add(Ve),
          this._adjustDialog(),
          this._backdrop.show(() => this._showElement(t)));
      }
      hide() {
        if (!this._isShown || this._isTransitioning) return;
        M.trigger(this._element, Pe).defaultPrevented ||
          ((this._isShown = !1),
          (this._isTransitioning = !0),
          this._focustrap.deactivate(),
          this._element.classList.remove(Ke),
          this._queueCallback(
            () => this._hideModal(),
            this._element,
            this._isAnimated(),
          ));
      }
      dispose() {
        M.off(window, Ne),
          M.off(this._dialog, Ne),
          this._backdrop.dispose(),
          this._focustrap.deactivate(),
          super.dispose();
      }
      handleUpdate() {
        this._adjustDialog();
      }
      _initializeBackDrop() {
        return new we({
          isVisible: Boolean(this._config.backdrop),
          isAnimated: this._isAnimated(),
        });
      }
      _initializeFocusTrap() {
        return new ke({ trapElement: this._element });
      }
      _showElement(t) {
        document.body.contains(this._element) ||
          document.body.append(this._element),
          (this._element.style.display = 'block'),
          this._element.removeAttribute('aria-hidden'),
          this._element.setAttribute('aria-modal', !0),
          this._element.setAttribute('role', 'dialog'),
          (this._element.scrollTop = 0);
        const e = V.findOne('.modal-body', this._dialog);
        e && (e.scrollTop = 0),
          p(this._element),
          this._element.classList.add(Ke);
        this._queueCallback(
          () => {
            this._config.focus && this._focustrap.activate(),
              (this._isTransitioning = !1),
              M.trigger(this._element, He, { relatedTarget: t });
          },
          this._dialog,
          this._isAnimated(),
        );
      }
      _addEventListeners() {
        M.on(this._element, qe, (t) => {
          'Escape' === t.key &&
            (this._config.keyboard
              ? this.hide()
              : this._triggerBackdropTransition());
        }),
          M.on(window, Be, () => {
            this._isShown && !this._isTransitioning && this._adjustDialog();
          }),
          M.on(this._element, ze, (t) => {
            M.one(this._element, We, (e) => {
              this._element === t.target &&
                this._element === e.target &&
                ('static' !== this._config.backdrop
                  ? this._config.backdrop && this.hide()
                  : this._triggerBackdropTransition());
            });
          });
      }
      _hideModal() {
        (this._element.style.display = 'none'),
          this._element.setAttribute('aria-hidden', !0),
          this._element.removeAttribute('aria-modal'),
          this._element.removeAttribute('role'),
          (this._isTransitioning = !1),
          this._backdrop.hide(() => {
            document.body.classList.remove(Ve),
              this._resetAdjustments(),
              this._scrollBar.reset(),
              M.trigger(this._element, Me);
          });
      }
      _isAnimated() {
        return this._element.classList.contains('fade');
      }
      _triggerBackdropTransition() {
        if (M.trigger(this._element, je).defaultPrevented) return;
        const t =
            this._element.scrollHeight > document.documentElement.clientHeight,
          e = this._element.style.overflowY;
        'hidden' === e ||
          this._element.classList.contains(Qe) ||
          (t || (this._element.style.overflowY = 'hidden'),
          this._element.classList.add(Qe),
          this._queueCallback(() => {
            this._element.classList.remove(Qe),
              this._queueCallback(() => {
                this._element.style.overflowY = e;
              }, this._dialog);
          }, this._dialog),
          this._element.focus());
      }
      _adjustDialog() {
        const t =
            this._element.scrollHeight > document.documentElement.clientHeight,
          e = this._scrollBar.getWidth(),
          i = e > 0;
        if (i && !t) {
          const t = _() ? 'paddingLeft' : 'paddingRight';
          this._element.style[t] = `${e}px`;
        }
        if (!i && t) {
          const t = _() ? 'paddingRight' : 'paddingLeft';
          this._element.style[t] = `${e}px`;
        }
      }
      _resetAdjustments() {
        (this._element.style.paddingLeft = ''),
          (this._element.style.paddingRight = '');
      }
      static jQueryInterface(t, e) {
        return this.each(function () {
          const i = Ue.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
            i[t](e);
          }
        });
      }
    }
    M.on(document, Re, '[data-bs-toggle="modal"]', function (t) {
      const e = V.getElementFromSelector(this);
      ['A', 'AREA'].includes(this.tagName) && t.preventDefault(),
        M.one(e, Fe, (t) => {
          t.defaultPrevented ||
            M.one(e, Me, () => {
              h(this) && this.focus();
            });
        });
      const i = V.findOne('.modal.show');
      i && Ue.getInstance(i).hide();
      Ue.getOrCreateInstance(e).toggle(this);
    }),
      K(Ue),
      b(Ue);
    const Ge = '.bs.offcanvas',
      Je = '.data-api',
      Ze = `load${Ge}${Je}`,
      ti = 'show',
      ei = 'showing',
      ii = 'hiding',
      ni = '.offcanvas.show',
      si = `show${Ge}`,
      oi = `shown${Ge}`,
      ri = `hide${Ge}`,
      ai = `hidePrevented${Ge}`,
      li = `hidden${Ge}`,
      ci = `resize${Ge}`,
      hi = `click${Ge}${Je}`,
      ui = `keydown.dismiss${Ge}`,
      di = { backdrop: !0, keyboard: !0, scroll: !1 },
      fi = {
        backdrop: '(boolean|string)',
        keyboard: 'boolean',
        scroll: 'boolean',
      };
    class pi extends q {
      constructor(t, e) {
        super(t, e),
          (this._isShown = !1),
          (this._backdrop = this._initializeBackDrop()),
          (this._focustrap = this._initializeFocusTrap()),
          this._addEventListeners();
      }
      static get Default() {
        return di;
      }
      static get DefaultType() {
        return fi;
      }
      static get NAME() {
        return 'offcanvas';
      }
      toggle(t) {
        return this._isShown ? this.hide() : this.show(t);
      }
      show(t) {
        if (this._isShown) return;
        if (M.trigger(this._element, si, { relatedTarget: t }).defaultPrevented)
          return;
        (this._isShown = !0),
          this._backdrop.show(),
          this._config.scroll || new Ie().hide(),
          this._element.setAttribute('aria-modal', !0),
          this._element.setAttribute('role', 'dialog'),
          this._element.classList.add(ei);
        this._queueCallback(
          () => {
            (this._config.scroll && !this._config.backdrop) ||
              this._focustrap.activate(),
              this._element.classList.add(ti),
              this._element.classList.remove(ei),
              M.trigger(this._element, oi, { relatedTarget: t });
          },
          this._element,
          !0,
        );
      }
      hide() {
        if (!this._isShown) return;
        if (M.trigger(this._element, ri).defaultPrevented) return;
        this._focustrap.deactivate(),
          this._element.blur(),
          (this._isShown = !1),
          this._element.classList.add(ii),
          this._backdrop.hide();
        this._queueCallback(
          () => {
            this._element.classList.remove(ti, ii),
              this._element.removeAttribute('aria-modal'),
              this._element.removeAttribute('role'),
              this._config.scroll || new Ie().reset(),
              M.trigger(this._element, li);
          },
          this._element,
          !0,
        );
      }
      dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
      }
      _initializeBackDrop() {
        const t = Boolean(this._config.backdrop);
        return new we({
          className: 'offcanvas-backdrop',
          isVisible: t,
          isAnimated: !0,
          rootElement: this._element.parentNode,
          clickCallback: t
            ? () => {
                'static' !== this._config.backdrop
                  ? this.hide()
                  : M.trigger(this._element, ai);
              }
            : null,
        });
      }
      _initializeFocusTrap() {
        return new ke({ trapElement: this._element });
      }
      _addEventListeners() {
        M.on(this._element, ui, (t) => {
          'Escape' === t.key &&
            (this._config.keyboard
              ? this.hide()
              : M.trigger(this._element, ai));
        });
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = pi.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t] || t.startsWith('_') || 'constructor' === t)
              throw new TypeError(`No method named "${t}"`);
            e[t](this);
          }
        });
      }
    }
    M.on(document, hi, '[data-bs-toggle="offcanvas"]', function (t) {
      const e = V.getElementFromSelector(this);
      if ((['A', 'AREA'].includes(this.tagName) && t.preventDefault(), u(this)))
        return;
      M.one(e, li, () => {
        h(this) && this.focus();
      });
      const i = V.findOne(ni);
      i && i !== e && pi.getInstance(i).hide();
      pi.getOrCreateInstance(e).toggle(this);
    }),
      M.on(window, Ze, () => {
        for (const t of V.find(ni)) pi.getOrCreateInstance(t).show();
      }),
      M.on(window, ci, () => {
        for (const t of V.find('[aria-modal][class*=show][class*=offcanvas-]'))
          'fixed' !== getComputedStyle(t).position &&
            pi.getOrCreateInstance(t).hide();
      }),
      K(pi),
      b(pi);
    const gi = {
        '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i],
        a: ['target', 'href', 'title', 'rel'],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
      },
      mi = new Set([
        'background',
        'cite',
        'href',
        'itemtype',
        'longdesc',
        'poster',
        'src',
        'xlink:href',
      ]),
      _i = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
      bi = (t, e) => {
        const i = t.nodeName.toLowerCase();
        return e.includes(i)
          ? !mi.has(i) || Boolean(_i.test(t.nodeValue))
          : e.filter((t) => t instanceof RegExp).some((t) => t.test(i));
      };
    const vi = {
        allowList: gi,
        content: {},
        extraClass: '',
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: '<div></div>',
      },
      yi = {
        allowList: 'object',
        content: 'object',
        extraClass: '(string|function)',
        html: 'boolean',
        sanitize: 'boolean',
        sanitizeFn: '(null|function)',
        template: 'string',
      },
      wi = {
        entry: '(string|element|function|null)',
        selector: '(string|element)',
      };
    class Ai extends z {
      constructor(t) {
        super(), (this._config = this._getConfig(t));
      }
      static get Default() {
        return vi;
      }
      static get DefaultType() {
        return yi;
      }
      static get NAME() {
        return 'TemplateFactory';
      }
      getContent() {
        return Object.values(this._config.content)
          .map((t) => this._resolvePossibleFunction(t))
          .filter(Boolean);
      }
      hasContent() {
        return this.getContent().length > 0;
      }
      changeContent(t) {
        return (
          this._checkContent(t),
          (this._config.content = { ...this._config.content, ...t }),
          this
        );
      }
      toHtml() {
        const t = document.createElement('div');
        t.innerHTML = this._maybeSanitize(this._config.template);
        for (const [e, i] of Object.entries(this._config.content))
          this._setContent(t, i, e);
        const e = t.children[0],
          i = this._resolvePossibleFunction(this._config.extraClass);
        return i && e.classList.add(...i.split(' ')), e;
      }
      _typeCheckConfig(t) {
        super._typeCheckConfig(t), this._checkContent(t.content);
      }
      _checkContent(t) {
        for (const [e, i] of Object.entries(t))
          super._typeCheckConfig({ selector: e, entry: i }, wi);
      }
      _setContent(t, e, i) {
        const n = V.findOne(i, t);
        n &&
          ((e = this._resolvePossibleFunction(e))
            ? l(e)
              ? this._putElementInTemplate(c(e), n)
              : this._config.html
              ? (n.innerHTML = this._maybeSanitize(e))
              : (n.textContent = e)
            : n.remove());
      }
      _maybeSanitize(t) {
        return this._config.sanitize
          ? (function (t, e, i) {
              if (!t.length) return t;
              if (i && 'function' == typeof i) return i(t);
              const n = new window.DOMParser().parseFromString(t, 'text/html'),
                s = [].concat(...n.body.querySelectorAll('*'));
              for (const t of s) {
                const i = t.nodeName.toLowerCase();
                if (!Object.keys(e).includes(i)) {
                  t.remove();
                  continue;
                }
                const n = [].concat(...t.attributes),
                  s = [].concat(e['*'] || [], e[i] || []);
                for (const e of n) bi(e, s) || t.removeAttribute(e.nodeName);
              }
              return n.body.innerHTML;
            })(t, this._config.allowList, this._config.sanitizeFn)
          : t;
      }
      _resolvePossibleFunction(t) {
        return v(t, [this]);
      }
      _putElementInTemplate(t, e) {
        if (this._config.html) return (e.innerHTML = ''), void e.append(t);
        e.textContent = t.textContent;
      }
    }
    const Ei = new Set(['sanitize', 'allowList', 'sanitizeFn']),
      Ti = 'fade',
      Ci = 'show',
      Oi = '.modal',
      xi = 'hide.bs.modal',
      ki = 'hover',
      Li = 'focus',
      Si = {
        AUTO: 'auto',
        TOP: 'top',
        RIGHT: _() ? 'left' : 'right',
        BOTTOM: 'bottom',
        LEFT: _() ? 'right' : 'left',
      },
      Di = {
        allowList: gi,
        animation: !0,
        boundary: 'clippingParents',
        container: !1,
        customClass: '',
        delay: 0,
        fallbackPlacements: ['top', 'right', 'bottom', 'left'],
        html: !1,
        offset: [0, 6],
        placement: 'top',
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template:
          '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: '',
        trigger: 'hover focus',
      },
      $i = {
        allowList: 'object',
        animation: 'boolean',
        boundary: '(string|element)',
        container: '(string|element|boolean)',
        customClass: '(string|function)',
        delay: '(number|object)',
        fallbackPlacements: 'array',
        html: 'boolean',
        offset: '(array|string|function)',
        placement: '(string|function)',
        popperConfig: '(null|object|function)',
        sanitize: 'boolean',
        sanitizeFn: '(null|function)',
        selector: '(string|boolean)',
        template: 'string',
        title: '(string|element|function)',
        trigger: 'string',
      };
    class Ii extends q {
      constructor(t, e) {
        if (void 0 === i)
          throw new TypeError(
            "Bootstrap's tooltips require Popper (https://popper.js.org)",
          );
        super(t, e),
          (this._isEnabled = !0),
          (this._timeout = 0),
          (this._isHovered = null),
          (this._activeTrigger = {}),
          (this._popper = null),
          (this._templateFactory = null),
          (this._newContent = null),
          (this.tip = null),
          this._setListeners(),
          this._config.selector || this._fixTitle();
      }
      static get Default() {
        return Di;
      }
      static get DefaultType() {
        return $i;
      }
      static get NAME() {
        return 'tooltip';
      }
      enable() {
        this._isEnabled = !0;
      }
      disable() {
        this._isEnabled = !1;
      }
      toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
      toggle() {
        this._isEnabled &&
          ((this._activeTrigger.click = !this._activeTrigger.click),
          this._isShown() ? this._leave() : this._enter());
      }
      dispose() {
        clearTimeout(this._timeout),
          M.off(this._element.closest(Oi), xi, this._hideModalHandler),
          this._element.getAttribute('data-bs-original-title') &&
            this._element.setAttribute(
              'title',
              this._element.getAttribute('data-bs-original-title'),
            ),
          this._disposePopper(),
          super.dispose();
      }
      show() {
        if ('none' === this._element.style.display)
          throw new Error('Please use show on visible elements');
        if (!this._isWithContent() || !this._isEnabled) return;
        const t = M.trigger(this._element, this.constructor.eventName('show')),
          e = (
            d(this._element) || this._element.ownerDocument.documentElement
          ).contains(this._element);
        if (t.defaultPrevented || !e) return;
        this._disposePopper();
        const i = this._getTipElement();
        this._element.setAttribute('aria-describedby', i.getAttribute('id'));
        const { container: n } = this._config;
        if (
          (this._element.ownerDocument.documentElement.contains(this.tip) ||
            (n.append(i),
            M.trigger(this._element, this.constructor.eventName('inserted'))),
          (this._popper = this._createPopper(i)),
          i.classList.add(Ci),
          'ontouchstart' in document.documentElement)
        )
          for (const t of [].concat(...document.body.children))
            M.on(t, 'mouseover', f);
        this._queueCallback(
          () => {
            M.trigger(this._element, this.constructor.eventName('shown')),
              !1 === this._isHovered && this._leave(),
              (this._isHovered = !1);
          },
          this.tip,
          this._isAnimated(),
        );
      }
      hide() {
        if (!this._isShown()) return;
        if (
          M.trigger(this._element, this.constructor.eventName('hide'))
            .defaultPrevented
        )
          return;
        if (
          (this._getTipElement().classList.remove(Ci),
          'ontouchstart' in document.documentElement)
        )
          for (const t of [].concat(...document.body.children))
            M.off(t, 'mouseover', f);
        (this._activeTrigger.click = !1),
          (this._activeTrigger[Li] = !1),
          (this._activeTrigger[ki] = !1),
          (this._isHovered = null);
        this._queueCallback(
          () => {
            this._isWithActiveTrigger() ||
              (this._isHovered || this._disposePopper(),
              this._element.removeAttribute('aria-describedby'),
              M.trigger(this._element, this.constructor.eventName('hidden')));
          },
          this.tip,
          this._isAnimated(),
        );
      }
      update() {
        this._popper && this._popper.update();
      }
      _isWithContent() {
        return Boolean(this._getTitle());
      }
      _getTipElement() {
        return (
          this.tip ||
            (this.tip = this._createTipElement(
              this._newContent || this._getContentForTemplate(),
            )),
          this.tip
        );
      }
      _createTipElement(t) {
        const e = this._getTemplateFactory(t).toHtml();
        if (!e) return null;
        e.classList.remove(Ti, Ci),
          e.classList.add(`bs-${this.constructor.NAME}-auto`);
        const i = ((t) => {
          do {
            t += Math.floor(1e6 * Math.random());
          } while (document.getElementById(t));
          return t;
        })(this.constructor.NAME).toString();
        return (
          e.setAttribute('id', i), this._isAnimated() && e.classList.add(Ti), e
        );
      }
      setContent(t) {
        (this._newContent = t),
          this._isShown() && (this._disposePopper(), this.show());
      }
      _getTemplateFactory(t) {
        return (
          this._templateFactory
            ? this._templateFactory.changeContent(t)
            : (this._templateFactory = new Ai({
                ...this._config,
                content: t,
                extraClass: this._resolvePossibleFunction(
                  this._config.customClass,
                ),
              })),
          this._templateFactory
        );
      }
      _getContentForTemplate() {
        return { '.tooltip-inner': this._getTitle() };
      }
      _getTitle() {
        return (
          this._resolvePossibleFunction(this._config.title) ||
          this._element.getAttribute('data-bs-original-title')
        );
      }
      _initializeOnDelegatedTarget(t) {
        return this.constructor.getOrCreateInstance(
          t.delegateTarget,
          this._getDelegateConfig(),
        );
      }
      _isAnimated() {
        return (
          this._config.animation ||
          (this.tip && this.tip.classList.contains(Ti))
        );
      }
      _isShown() {
        return this.tip && this.tip.classList.contains(Ci);
      }
      _createPopper(t) {
        const e = v(this._config.placement, [this, t, this._element]),
          n = Si[e.toUpperCase()];
        return i.createPopper(this._element, t, this._getPopperConfig(n));
      }
      _getOffset() {
        const { offset: t } = this._config;
        return 'string' == typeof t
          ? t.split(',').map((t) => Number.parseInt(t, 10))
          : 'function' == typeof t
          ? (e) => t(e, this._element)
          : t;
      }
      _resolvePossibleFunction(t) {
        return v(t, [this._element]);
      }
      _getPopperConfig(t) {
        const e = {
          placement: t,
          modifiers: [
            {
              name: 'flip',
              options: { fallbackPlacements: this._config.fallbackPlacements },
            },
            { name: 'offset', options: { offset: this._getOffset() } },
            {
              name: 'preventOverflow',
              options: { boundary: this._config.boundary },
            },
            {
              name: 'arrow',
              options: { element: `.${this.constructor.NAME}-arrow` },
            },
            {
              name: 'preSetPlacement',
              enabled: !0,
              phase: 'beforeMain',
              fn: (t) => {
                this._getTipElement().setAttribute(
                  'data-popper-placement',
                  t.state.placement,
                );
              },
            },
          ],
        };
        return { ...e, ...v(this._config.popperConfig, [e]) };
      }
      _setListeners() {
        const t = this._config.trigger.split(' ');
        for (const e of t)
          if ('click' === e)
            M.on(
              this._element,
              this.constructor.eventName('click'),
              this._config.selector,
              (t) => {
                this._initializeOnDelegatedTarget(t).toggle();
              },
            );
          else if ('manual' !== e) {
            const t =
                e === ki
                  ? this.constructor.eventName('mouseenter')
                  : this.constructor.eventName('focusin'),
              i =
                e === ki
                  ? this.constructor.eventName('mouseleave')
                  : this.constructor.eventName('focusout');
            M.on(this._element, t, this._config.selector, (t) => {
              const e = this._initializeOnDelegatedTarget(t);
              (e._activeTrigger['focusin' === t.type ? Li : ki] = !0),
                e._enter();
            }),
              M.on(this._element, i, this._config.selector, (t) => {
                const e = this._initializeOnDelegatedTarget(t);
                (e._activeTrigger['focusout' === t.type ? Li : ki] =
                  e._element.contains(t.relatedTarget)),
                  e._leave();
              });
          }
        (this._hideModalHandler = () => {
          this._element && this.hide();
        }),
          M.on(this._element.closest(Oi), xi, this._hideModalHandler);
      }
      _fixTitle() {
        const t = this._element.getAttribute('title');
        t &&
          (this._element.getAttribute('aria-label') ||
            this._element.textContent.trim() ||
            this._element.setAttribute('aria-label', t),
          this._element.setAttribute('data-bs-original-title', t),
          this._element.removeAttribute('title'));
      }
      _enter() {
        this._isShown() || this._isHovered
          ? (this._isHovered = !0)
          : ((this._isHovered = !0),
            this._setTimeout(() => {
              this._isHovered && this.show();
            }, this._config.delay.show));
      }
      _leave() {
        this._isWithActiveTrigger() ||
          ((this._isHovered = !1),
          this._setTimeout(() => {
            this._isHovered || this.hide();
          }, this._config.delay.hide));
      }
      _setTimeout(t, e) {
        clearTimeout(this._timeout), (this._timeout = setTimeout(t, e));
      }
      _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0);
      }
      _getConfig(t) {
        const e = W.getDataAttributes(this._element);
        for (const t of Object.keys(e)) Ei.has(t) && delete e[t];
        return (
          (t = { ...e, ...('object' == typeof t && t ? t : {}) }),
          (t = this._mergeConfigObj(t)),
          (t = this._configAfterMerge(t)),
          this._typeCheckConfig(t),
          t
        );
      }
      _configAfterMerge(t) {
        return (
          (t.container = !1 === t.container ? document.body : c(t.container)),
          'number' == typeof t.delay &&
            (t.delay = { show: t.delay, hide: t.delay }),
          'number' == typeof t.title && (t.title = t.title.toString()),
          'number' == typeof t.content && (t.content = t.content.toString()),
          t
        );
      }
      _getDelegateConfig() {
        const t = {};
        for (const [e, i] of Object.entries(this._config))
          this.constructor.Default[e] !== i && (t[e] = i);
        return (t.selector = !1), (t.trigger = 'manual'), t;
      }
      _disposePopper() {
        this._popper && (this._popper.destroy(), (this._popper = null)),
          this.tip && (this.tip.remove(), (this.tip = null));
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = Ii.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        });
      }
    }
    b(Ii);
    const Ni = {
        ...Ii.Default,
        content: '',
        offset: [0, 8],
        placement: 'right',
        template:
          '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: 'click',
      },
      Pi = { ...Ii.DefaultType, content: '(null|string|element|function)' };
    class ji extends Ii {
      static get Default() {
        return Ni;
      }
      static get DefaultType() {
        return Pi;
      }
      static get NAME() {
        return 'popover';
      }
      _isWithContent() {
        return this._getTitle() || this._getContent();
      }
      _getContentForTemplate() {
        return {
          '.popover-header': this._getTitle(),
          '.popover-body': this._getContent(),
        };
      }
      _getContent() {
        return this._resolvePossibleFunction(this._config.content);
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = ji.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        });
      }
    }
    b(ji);
    const Mi = '.bs.scrollspy',
      Fi = `activate${Mi}`,
      Hi = `click${Mi}`,
      Bi = `load${Mi}.data-api`,
      Wi = 'active',
      zi = '[href]',
      qi = '.nav-link',
      Ri = `${qi}, .nav-item > ${qi}, .list-group-item`,
      Vi = {
        offset: null,
        rootMargin: '0px 0px -25%',
        smoothScroll: !1,
        target: null,
        threshold: [0.1, 0.5, 1],
      },
      Ki = {
        offset: '(number|null)',
        rootMargin: 'string',
        smoothScroll: 'boolean',
        target: 'element',
        threshold: 'array',
      };
    class Qi extends q {
      constructor(t, e) {
        super(t, e),
          (this._targetLinks = new Map()),
          (this._observableSections = new Map()),
          (this._rootElement =
            'visible' === getComputedStyle(this._element).overflowY
              ? null
              : this._element),
          (this._activeTarget = null),
          (this._observer = null),
          (this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0,
          }),
          this.refresh();
      }
      static get Default() {
        return Vi;
      }
      static get DefaultType() {
        return Ki;
      }
      static get NAME() {
        return 'scrollspy';
      }
      refresh() {
        this._initializeTargetsAndObservables(),
          this._maybeEnableSmoothScroll(),
          this._observer
            ? this._observer.disconnect()
            : (this._observer = this._getNewObserver());
        for (const t of this._observableSections.values())
          this._observer.observe(t);
      }
      dispose() {
        this._observer.disconnect(), super.dispose();
      }
      _configAfterMerge(t) {
        return (
          (t.target = c(t.target) || document.body),
          (t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin),
          'string' == typeof t.threshold &&
            (t.threshold = t.threshold
              .split(',')
              .map((t) => Number.parseFloat(t))),
          t
        );
      }
      _maybeEnableSmoothScroll() {
        this._config.smoothScroll &&
          (M.off(this._config.target, Hi),
          M.on(this._config.target, Hi, zi, (t) => {
            const e = this._observableSections.get(t.target.hash);
            if (e) {
              t.preventDefault();
              const i = this._rootElement || window,
                n = e.offsetTop - this._element.offsetTop;
              if (i.scrollTo)
                return void i.scrollTo({ top: n, behavior: 'smooth' });
              i.scrollTop = n;
            }
          }));
      }
      _getNewObserver() {
        const t = {
          root: this._rootElement,
          threshold: this._config.threshold,
          rootMargin: this._config.rootMargin,
        };
        return new IntersectionObserver((t) => this._observerCallback(t), t);
      }
      _observerCallback(t) {
        const e = (t) => this._targetLinks.get(`#${t.target.id}`),
          i = (t) => {
            (this._previousScrollData.visibleEntryTop = t.target.offsetTop),
              this._process(e(t));
          },
          n = (this._rootElement || document.documentElement).scrollTop,
          s = n >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = n;
        for (const o of t) {
          if (!o.isIntersecting) {
            (this._activeTarget = null), this._clearActiveClass(e(o));
            continue;
          }
          const t =
            o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
          if (s && t) {
            if ((i(o), !n)) return;
          } else s || t || i(o);
        }
      }
      _initializeTargetsAndObservables() {
        (this._targetLinks = new Map()), (this._observableSections = new Map());
        const t = V.find(zi, this._config.target);
        for (const e of t) {
          if (!e.hash || u(e)) continue;
          const t = V.findOne(decodeURI(e.hash), this._element);
          h(t) &&
            (this._targetLinks.set(decodeURI(e.hash), e),
            this._observableSections.set(e.hash, t));
        }
      }
      _process(t) {
        this._activeTarget !== t &&
          (this._clearActiveClass(this._config.target),
          (this._activeTarget = t),
          t.classList.add(Wi),
          this._activateParents(t),
          M.trigger(this._element, Fi, { relatedTarget: t }));
      }
      _activateParents(t) {
        if (t.classList.contains('dropdown-item'))
          V.findOne('.dropdown-toggle', t.closest('.dropdown')).classList.add(
            Wi,
          );
        else
          for (const e of V.parents(t, '.nav, .list-group'))
            for (const t of V.prev(e, Ri)) t.classList.add(Wi);
      }
      _clearActiveClass(t) {
        t.classList.remove(Wi);
        const e = V.find(`${zi}.${Wi}`, t);
        for (const t of e) t.classList.remove(Wi);
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = Qi.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t] || t.startsWith('_') || 'constructor' === t)
              throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        });
      }
    }
    M.on(window, Bi, () => {
      for (const t of V.find('[data-bs-spy="scroll"]'))
        Qi.getOrCreateInstance(t);
    }),
      b(Qi);
    const Xi = '.bs.tab',
      Yi = `hide${Xi}`,
      Ui = `hidden${Xi}`,
      Gi = `show${Xi}`,
      Ji = `shown${Xi}`,
      Zi = `click${Xi}`,
      tn = `keydown${Xi}`,
      en = `load${Xi}`,
      nn = 'ArrowLeft',
      sn = 'ArrowRight',
      on = 'ArrowUp',
      rn = 'ArrowDown',
      an = 'Home',
      ln = 'End',
      cn = 'active',
      hn = 'fade',
      un = 'show',
      dn = '.dropdown-toggle',
      fn = `:not(${dn})`,
      pn =
        '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
      gn = `${`.nav-link${fn}, .list-group-item${fn}, [role="tab"]${fn}`}, ${pn}`,
      mn = `.${cn}[data-bs-toggle="tab"], .${cn}[data-bs-toggle="pill"], .${cn}[data-bs-toggle="list"]`;
    class _n extends q {
      constructor(t) {
        super(t),
          (this._parent = this._element.closest(
            '.list-group, .nav, [role="tablist"]',
          )),
          this._parent &&
            (this._setInitialAttributes(this._parent, this._getChildren()),
            M.on(this._element, tn, (t) => this._keydown(t)));
      }
      static get NAME() {
        return 'tab';
      }
      show() {
        const t = this._element;
        if (this._elemIsActive(t)) return;
        const e = this._getActiveElem(),
          i = e ? M.trigger(e, Yi, { relatedTarget: t }) : null;
        M.trigger(t, Gi, { relatedTarget: e }).defaultPrevented ||
          (i && i.defaultPrevented) ||
          (this._deactivate(e, t), this._activate(t, e));
      }
      _activate(t, e) {
        if (!t) return;
        t.classList.add(cn), this._activate(V.getElementFromSelector(t));
        this._queueCallback(
          () => {
            'tab' === t.getAttribute('role')
              ? (t.removeAttribute('tabindex'),
                t.setAttribute('aria-selected', !0),
                this._toggleDropDown(t, !0),
                M.trigger(t, Ji, { relatedTarget: e }))
              : t.classList.add(un);
          },
          t,
          t.classList.contains(hn),
        );
      }
      _deactivate(t, e) {
        if (!t) return;
        t.classList.remove(cn),
          t.blur(),
          this._deactivate(V.getElementFromSelector(t));
        this._queueCallback(
          () => {
            'tab' === t.getAttribute('role')
              ? (t.setAttribute('aria-selected', !1),
                t.setAttribute('tabindex', '-1'),
                this._toggleDropDown(t, !1),
                M.trigger(t, Ui, { relatedTarget: e }))
              : t.classList.remove(un);
          },
          t,
          t.classList.contains(hn),
        );
      }
      _keydown(t) {
        if (![nn, sn, on, rn, an, ln].includes(t.key)) return;
        t.stopPropagation(), t.preventDefault();
        const e = this._getChildren().filter((t) => !u(t));
        let i;
        if ([an, ln].includes(t.key)) i = e[t.key === an ? 0 : e.length - 1];
        else {
          const n = [sn, rn].includes(t.key);
          i = w(e, t.target, n, !0);
        }
        i && (i.focus({ preventScroll: !0 }), _n.getOrCreateInstance(i).show());
      }
      _getChildren() {
        return V.find(gn, this._parent);
      }
      _getActiveElem() {
        return this._getChildren().find((t) => this._elemIsActive(t)) || null;
      }
      _setInitialAttributes(t, e) {
        this._setAttributeIfNotExists(t, 'role', 'tablist');
        for (const t of e) this._setInitialAttributesOnChild(t);
      }
      _setInitialAttributesOnChild(t) {
        t = this._getInnerElement(t);
        const e = this._elemIsActive(t),
          i = this._getOuterElement(t);
        t.setAttribute('aria-selected', e),
          i !== t && this._setAttributeIfNotExists(i, 'role', 'presentation'),
          e || t.setAttribute('tabindex', '-1'),
          this._setAttributeIfNotExists(t, 'role', 'tab'),
          this._setInitialAttributesOnTargetPanel(t);
      }
      _setInitialAttributesOnTargetPanel(t) {
        const e = V.getElementFromSelector(t);
        e &&
          (this._setAttributeIfNotExists(e, 'role', 'tabpanel'),
          t.id &&
            this._setAttributeIfNotExists(e, 'aria-labelledby', `${t.id}`));
      }
      _toggleDropDown(t, e) {
        const i = this._getOuterElement(t);
        if (!i.classList.contains('dropdown')) return;
        const n = (t, n) => {
          const s = V.findOne(t, i);
          s && s.classList.toggle(n, e);
        };
        n(dn, cn), n('.dropdown-menu', un), i.setAttribute('aria-expanded', e);
      }
      _setAttributeIfNotExists(t, e, i) {
        t.hasAttribute(e) || t.setAttribute(e, i);
      }
      _elemIsActive(t) {
        return t.classList.contains(cn);
      }
      _getInnerElement(t) {
        return t.matches(gn) ? t : V.findOne(gn, t);
      }
      _getOuterElement(t) {
        return t.closest('.nav-item, .list-group-item') || t;
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = _n.getOrCreateInstance(this);
          if ('string' == typeof t) {
            if (void 0 === e[t] || t.startsWith('_') || 'constructor' === t)
              throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        });
      }
    }
    M.on(document, Zi, pn, function (t) {
      ['A', 'AREA'].includes(this.tagName) && t.preventDefault(),
        u(this) || _n.getOrCreateInstance(this).show();
    }),
      M.on(window, en, () => {
        for (const t of V.find(mn)) _n.getOrCreateInstance(t);
      }),
      b(_n);
    const bn = '.bs.toast',
      vn = `mouseover${bn}`,
      yn = `mouseout${bn}`,
      wn = `focusin${bn}`,
      An = `focusout${bn}`,
      En = `hide${bn}`,
      Tn = `hidden${bn}`,
      Cn = `show${bn}`,
      On = `shown${bn}`,
      xn = 'hide',
      kn = 'show',
      Ln = 'showing',
      Sn = { animation: 'boolean', autohide: 'boolean', delay: 'number' },
      Dn = { animation: !0, autohide: !0, delay: 5e3 };
    class $n extends q {
      constructor(t, e) {
        super(t, e),
          (this._timeout = null),
          (this._hasMouseInteraction = !1),
          (this._hasKeyboardInteraction = !1),
          this._setListeners();
      }
      static get Default() {
        return Dn;
      }
      static get DefaultType() {
        return Sn;
      }
      static get NAME() {
        return 'toast';
      }
      show() {
        if (M.trigger(this._element, Cn).defaultPrevented) return;
        this._clearTimeout(),
          this._config.animation && this._element.classList.add('fade');
        this._element.classList.remove(xn),
          p(this._element),
          this._element.classList.add(kn, Ln),
          this._queueCallback(
            () => {
              this._element.classList.remove(Ln),
                M.trigger(this._element, On),
                this._maybeScheduleHide();
            },
            this._element,
            this._config.animation,
          );
      }
      hide() {
        if (!this.isShown()) return;
        if (M.trigger(this._element, En).defaultPrevented) return;
        this._element.classList.add(Ln),
          this._queueCallback(
            () => {
              this._element.classList.add(xn),
                this._element.classList.remove(Ln, kn),
                M.trigger(this._element, Tn);
            },
            this._element,
            this._config.animation,
          );
      }
      dispose() {
        this._clearTimeout(),
          this.isShown() && this._element.classList.remove(kn),
          super.dispose();
      }
      isShown() {
        return this._element.classList.contains(kn);
      }
      _maybeScheduleHide() {
        this._config.autohide &&
          (this._hasMouseInteraction ||
            this._hasKeyboardInteraction ||
            (this._timeout = setTimeout(() => {
              this.hide();
            }, this._config.delay)));
      }
      _onInteraction(t, e) {
        switch (t.type) {
          case 'mouseover':
          case 'mouseout':
            this._hasMouseInteraction = e;
            break;
          case 'focusin':
          case 'focusout':
            this._hasKeyboardInteraction = e;
        }
        if (e) return void this._clearTimeout();
        const i = t.relatedTarget;
        this._element === i ||
          this._element.contains(i) ||
          this._maybeScheduleHide();
      }
      _setListeners() {
        M.on(this._element, vn, (t) => this._onInteraction(t, !0)),
          M.on(this._element, yn, (t) => this._onInteraction(t, !1)),
          M.on(this._element, wn, (t) => this._onInteraction(t, !0)),
          M.on(this._element, An, (t) => this._onInteraction(t, !1));
      }
      _clearTimeout() {
        clearTimeout(this._timeout), (this._timeout = null);
      }
      static jQueryInterface(t) {
        return this.each(function () {
          const e = $n.getOrCreateInstance(this, t);
          if ('string' == typeof t) {
            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
            e[t](this);
          }
        });
      }
    }
    K($n), b($n);
    return {
      Alert: U,
      Button: J,
      Carousel: St,
      Collapse: Rt,
      Dropdown: ge,
      Modal: Ue,
      Offcanvas: pi,
      Popover: ji,
      ScrollSpy: Qi,
      Tab: _n,
      Toast: $n,
      Tooltip: Ii,
    };
  });
//# sourceMappingURL=vendors.min.js.map
